synced with libmodplug git -- with further changes, including:

- don't export cplusplus interface from shared libs. SDL_mixer doesn't use it.
- disable wav formats handling: SDL_mixer has its own code for it.
- disable midi formats handling: SDL_mixer has timidity or native midi for it.
- disable mmcmp unpacking. disable broken pp20 unpacking.
- removed experimental file save support: no one uses it, ever.
- removed irrelevant/dead modplug tracker/player code: not enabled ever.
- load_med.cpp: fix an old incorrect logic in boundary check.
- merge libmodplug github PR/50 (fix broken bitshifts in X86_Convert32To24)
- merge libmodplug github PR/46 (unbalanced pragma pack fix)
- merge libmodplug github PR/39 (case-sensitive STM signature checks)
- merge libmodplug github PR/45 (_MSC_VER ifdef corrections)
- merge libmodplug github PR/32 (replace setenv)
- merge libmodplug github PR/41 (timidity paths update)
- merge libmodplug github PR/24 (make some stuff static)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 468f1a3..34099d8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,19 +1,73 @@
 cmake_minimum_required(VERSION 2.8.0)
 
 project(libmodplug)
+
+set(VERSION "0.8.9.0")
+
+option(BUILD_SHARED_LIBS "Build Shared Library (DLL)" OFF)
+option(EXPORT_CXX "Export C++ interface from library" ON)
+option(MIDIFMT_SUPPORT "Enable midi formats support" OFF)
+option(WAV_SUPPORT "Enable wav formats support" OFF)
+option(MMCMP_SUPPORT "Enable mmcmp and pp20 decompression support" OFF)
+
 add_definitions(-DMODPLUG_BUILD)
+if(MIDIFMT_SUPPORT)
+  add_definitions(-DMIDIFMT_SUPPORT)
+endif()
+if(WAV_SUPPORT)
+  add_definitions(-DWAV_SUPPORT)
+endif()
+if(MMCMP_SUPPORT)
+  add_definitions(-DMMCMP_SUPPORT)
+endif()
+if(NOT EXPORT_CXX)
+  add_definitions(-DNO_CXX_EXPORTS)
+else()
+  set(HEADERS_CXX
+      src/libmodplug/it_defs.h
+      src/libmodplug/sndfile.h
+      src/libmodplug/stdafx.h)
+endif()
 
 include (CheckFunctionExists)
 include (CheckIncludeFile)
+include (CheckCCompilerFlag)
+include (CheckCSourceCompiles)
+include (TestBigEndian)
+
+TEST_BIG_ENDIAN(WORDS_BIGENDIAN)
+if(WORDS_BIGENDIAN)
+  add_definitions(-DWORDS_BIGENDIAN=1)
+endif()
+
+if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES "Clang")
+  add_definitions(-Wall)
+  # check symbol visibility attributes
+  set(OLD_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS}")
+  if(NOT WIN32 AND NOT CYGWIN)
+    set(CMAKE_REQUIRED_FLAGS "${OLD_REQUIRED_FLAGS} -Werror")
+    check_c_source_compiles("int foo(void) __attribute__((visibility(\"default\")));
+                             int main(void) {return 0;}" HAVE_VISIBILITY_DEFAULT)
+    if(HAVE_VISIBILITY_DEFAULT)
+      check_c_compiler_flag(-fvisibility=hidden HAVE_VISIBILITY_HIDDEN)
+    endif()
+  endif()
+  set(CMAKE_REQUIRED_FLAGS "-Wl,--no-undefined")
+  check_c_compiler_flag("" HAVE_NO_UNDEFINED)
+  set(CMAKE_REQUIRED_FLAGS "${OLD_REQUIRED_FLAGS}")
+endif()
 
 include_directories(AFTER
   src
   src/libmodplug
   ${PROJECT_BINARY_DIR}
-  )
+)
 
-if (UNIX)
-  set (CMAKE_REQUIRED_LIBRARIES m)
+if(UNIX AND NOT APPLE)
+  find_library(MATH_LIB m)
+  if(MATH_LIB)
+    set(CMAKE_REQUIRED_LIBRARIES m)
+  endif()
 endif()
 
 if (WIN32)
@@ -21,58 +75,28 @@ if (WIN32)
   add_definitions(-DNOMINMAX)
 endif()
 
-if (WIN32 AND NOT (MINGW OR MSYS))
-  set(MSINTTYPES_PATH "$ENV{MSINTTYPES_PATH}" CACHE PATH "search path for inttypes.h and stdint.h")
-
-  find_path(STDINT_INCLUDE_DIR
-    stdint.h
-    PATHS
-    ${MSINTTYPES_PATH})
-
-  if (STDINT_INCLUDE_DIR)
-    add_definitions(-DHAVE_STDINT_H)
-    include_directories(AFTER "${STDINT_INCLUDE_DIR}")
-  endif()
-
-  find_path(INTTYPES_INCLUDE_DIR
-    inttypes.h
-    PATHS
-    ${MSINTTYPES_PATH})
-
-  if (INTTYPES_INCLUDE_DIR)
-    add_definitions(-DHAVE_INTTYPES_H)
-    include_directories(AFTER "${INTTYPES_INCLUDE_DIR}")
-  endif()
-
-  if (NOT STDINT_INCLUDE_DIR OR NOT INTTYPES_INCLUDE_DIR)
-    message(WARNING
-      "Compilation may fail if inttypes.h is not natively supported by the compiler."
-      "You can get inttypes.h from http://code.google.com/p/msinttypes/")
-  endif()
-else()
-  check_include_file("stdint.h" HAVE_STDINT)
-  if (HAVE_STDINT)
-    add_definitions(-DHAVE_STDINT_H)
-  endif()
+check_include_file("stdint.h" HAVE_STDINT)
+if (HAVE_STDINT)
+  add_definitions(-DHAVE_STDINT_H)
 endif()
 
-check_function_exists("setenv" HAVE_SETENV)
 check_function_exists("sinf" HAVE_SINF)
-
-# Allow the developer to select if Dynamic or Static libraries are built
-option(BUILD_SHARED_LIBS "Build Shared Library (DLL)" OFF)
-
-# Set the LIB_TYPE variable to STATIC
-set(LIB_TYPE STATIC)
+if(HAVE_SINF)
+  add_definitions(-DHAVE_SINF)
+endif()
 
 if (BUILD_SHARED_LIBS)
-  # User wants to build Dynamic Libraries,
-  # so change the LIB_TYPE variable to CMake keyword 'SHARED'
   set (LIB_TYPE SHARED)
-  add_definitions(-DDLL_EXPORT)
-else (BUILD_SHARED_LIBS)
+  if (WIN32 OR CYGWIN)
+    add_definitions(-DDLL_EXPORT)
+  elseif (HAVE_VISIBILITY_HIDDEN)
+    add_definitions(-fvisibility=hidden)
+    add_definitions("-DSYM_VISIBILITY")
+  endif()
+else ()
+  set(LIB_TYPE STATIC)
   add_definitions(-DMODPLUG_STATIC)
-endif (BUILD_SHARED_LIBS)
+endif()
 
 add_library(modplug ${LIB_TYPE}
   src/libmodplug/it_defs.h
@@ -89,7 +113,6 @@ add_library(modplug ${LIB_TYPE}
   src/load_dsm.cpp
   src/load_far.cpp
   src/load_it.cpp
-  src/load_j2b.cpp
   src/load_mdl.cpp
   src/load_med.cpp
   src/load_mid.cpp
@@ -116,30 +139,36 @@ add_library(modplug ${LIB_TYPE}
   src/sndfile.cpp
   src/sndmix.cpp
   src/tables.h
-  )
+)
+
+if (BUILD_SHARED_LIBS)
+  if(APPLE)
+    target_link_libraries(modplug -Wl,-undefined,error)
+    target_link_libraries(modplug -Wl,-compatibility_version,2.0.0)
+    target_link_libraries(modplug -Wl,-current_version,2.0.0)
+  else()
+    if(HAVE_NO_UNDEFINED)
+      target_link_libraries(modplug -Wl,--no-undefined)
+    endif()
+    set_target_properties(modplug PROPERTIES
+                                  VERSION 1.0.0 SOVERSION 1)
+  endif()
+  if(MATH_LIB)
+    target_link_libraries(modplug m)
+  endif()
+endif()
 
 # install the library:
 install(TARGETS modplug DESTINATION lib)
 
-# incstall the headers:
+# install the headers:
 install(FILES
-  src/libmodplug/it_defs.h
-  src/libmodplug/sndfile.h
-  src/libmodplug/stdafx.h
   src/modplug.h
+  ${HEADERS_CXX}
 
   DESTINATION
   include/libmodplug
-  )
-
-set(VERSION "0.8.8.5")
-
-if(HAVE_SETENV)
-  add_definitions(-DHAVE_SETENV)
-endif(HAVE_SETENV)
-if(HAVE_SINF)
-  add_definitions(-DHAVE_SINF)
-endif(HAVE_SINF)
+)
 
 if (NOT WIN32)
   set(prefix "${CMAKE_INSTALL_PREFIX}")
diff --git a/Makefile.am b/Makefile.am
index abb51c1..0bf6578 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2,7 +2,7 @@ ACLOCAL_AMFLAGS = -I m4
 
 SUBDIRS = src
 
-EXTRA_DIST =	 \
+EXTRA_DIST = CMakeLists.txt \
 	AUTHORS COPYING ChangeLog \
 	INSTALL README TODO
 
diff --git a/configure.ac b/configure.ac
index f96a28e..42a161d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -29,7 +29,7 @@ LT_INIT([win32-dll])
 
 AC_HEADER_STDC
 AC_CHECK_HEADERS([inttypes.h stdint.h malloc.h])
-AC_CHECK_FUNCS(setenv sinf)
+AC_CHECK_FUNCS(sinf)
 
 CXXFLAGS="$CXXFLAGS -fno-exceptions -Wall -ffast-math -fno-common -D_REENTRANT"
 
@@ -82,6 +82,39 @@ case ${target_os} in
 		;;
 esac
 
+AC_ARG_ENABLE([cxx_interface],
+    [AS_HELP_STRING([--enable-cxx-interface],
+                    [export C++ interface from library [[default=yes]]])],,
+    [enable_cxx_interface=yes])
+if test x$enable_cxx_interface != xyes; then
+    AC_DEFINE(NO_CXX_EXPORTS, 1, [Do not export the C++ interface.])
+fi
+AM_CONDITIONAL(EXPORT_CXX, test x$enable_cxx_interface = xyes)
+
+AC_ARG_ENABLE([midi],
+    [AS_HELP_STRING([--enable-midi],
+                    [compile with midi formats support [[default=no]]])],,
+    [enable_midi=no])
+if test x$enable_midi = xyes; then
+    AC_DEFINE(MIDIFMT_SUPPORT, 1, [Enable midi formats support.])
+fi
+
+AC_ARG_ENABLE([wav],
+    [AS_HELP_STRING([--enable-wav],
+                    [compile with wav formats support [[default=no]]])],,
+    [enable_wav=no])
+if test x$enable_wav = xyes; then
+    AC_DEFINE(WAV_SUPPORT, 1, [Enable wav formats support.])
+fi
+
+AC_ARG_ENABLE([mmcmp],
+    [AS_HELP_STRING([--enable-mmcmp],
+                    [compile with mmcmp and pp20 decompression support [[default=no]]])],,
+    [enable_mmcmp=no])
+if test x$enable_mmcmp = xyes; then
+    AC_DEFINE(MMCMP_SUPPORT, 1, [Enable mmcmp and pp20 decompression support.])
+fi
+
 # portable types. requires autoconf 2.60
 # `configure' will check if these are defined in system headers.
 # if not, it will auto-detect and define them in `config.h'
@@ -99,6 +132,6 @@ MODPLUG_LIBRARY_VERSION=1:0:0
 AC_SUBST(MODPLUG_LIBRARY_VERSION)
 
 AC_CONFIG_FILES([Makefile
-          src/Makefile
+	  src/Makefile
 	  libmodplug.pc])
 AC_OUTPUT
diff --git a/src/Makefile.am b/src/Makefile.am
index 19b32cc..00cecf4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -35,7 +35,6 @@ libmodplug_la_SOURCES = tables.h         \
                         load_ams.cpp       \
                         load_amf.cpp       \
                         load_669.cpp       \
-                        load_j2b.cpp       \
                         load_mt2.cpp       \
                         load_psm.cpp       \
                         load_abc.cpp       \
@@ -45,6 +44,8 @@ libmodplug_la_SOURCES = tables.h         \
 
 libmodplugincludedir = $(includedir)/libmodplug
 
-
-libmodpluginclude_HEADERS = libmodplug/stdafx.h libmodplug/sndfile.h libmodplug/it_defs.h modplug.h
+if EXPORT_CXX
+HEADERS_CXX = libmodplug/stdafx.h libmodplug/sndfile.h libmodplug/it_defs.h
+endif
+libmodpluginclude_HEADERS = modplug.h $(HEADERS_CXX)
 noinst_HEADERS = load_pat.h
diff --git a/src/config.h.in b/src/config.h.in
index 4190283..2eb5f6a 100644
--- a/src/config.h.in
+++ b/src/config.h.in
@@ -15,9 +15,6 @@
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
-/* Define to 1 if you have the `setenv' function. */
-#undef HAVE_SETENV
-
 /* Define to 1 if you have the `sinf' function. */
 #undef HAVE_SINF
 
@@ -45,6 +42,15 @@
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #undef LT_OBJDIR
 
+/* Enable midi formats support. */
+#undef MIDIFMT_SUPPORT
+
+/* Enable mmcmp and pp20 decompression support. */
+#undef MMCMP_SUPPORT
+
+/* Do not export the C++ interface. */
+#undef NO_CXX_EXPORTS
+
 /* Name of package */
 #undef PACKAGE
 
@@ -72,6 +78,9 @@
 /* Version number of package */
 #undef VERSION
 
+/* Enable wav formats support. */
+#undef WAV_SUPPORT
+
 /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
    significant byte first (like Motorola and SPARC, unlike Intel). */
 #if defined AC_APPLE_UNIVERSAL_BUILD
diff --git a/src/fastmix.cpp b/src/fastmix.cpp
index d693d20..7aad373 100644
--- a/src/fastmix.cpp
+++ b/src/fastmix.cpp
@@ -9,7 +9,7 @@
 #include "sndfile.h"
 #include <math.h>
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 #pragma bss_seg(".modplug")
 #endif
 
@@ -27,7 +27,7 @@ int MixRearBuffer[MIXBUFFERSIZE*2];
 float MixFloatBuffer[MIXBUFFERSIZE*2];
 #endif
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 #pragma bss_seg()
 #endif
 
@@ -287,8 +287,14 @@ CzWINDOWEDFIR sfir;
 // ----------------------------------------------------------------------------
 // MIXING MACROS
 // ----------------------------------------------------------------------------
+#if defined(__cplusplus) && (__cplusplus >= 201402L)
+#define REGISTER
+#else
+#define REGISTER register
+#endif
+
 #define SNDMIX_BEGINSAMPLELOOP8\
-	register MODCHANNEL * const pChn = pChannel;\
+	REGISTER MODCHANNEL * const pChn = pChannel;\
 	nPos = pChn->nPosLo;\
 	const signed char *p = (signed char *)(pChn->pCurrentSample+pChn->nPos);\
 	if (pChn->dwFlags & CHN_STEREO) p += pChn->nPos;\
@@ -296,7 +302,7 @@ CzWINDOWEDFIR sfir;
 	do {
 
 #define SNDMIX_BEGINSAMPLELOOP16\
-	register MODCHANNEL * const pChn = pChannel;\
+	REGISTER MODCHANNEL * const pChn = pChannel;\
 	nPos = pChn->nPosLo;\
 	const signed short *p = (signed short *)(pChn->pCurrentSample+(pChn->nPos*2));\
 	if (pChn->dwFlags & CHN_STEREO) p += pChn->nPos;\
@@ -1611,7 +1617,7 @@ UINT CSoundFile::CreateStereoMix(int count)
 #endif
 
 // Clip and convert to 8 bit
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 __declspec(naked) DWORD MPPASMCALL X86_Convert32To8(LPVOID lp16, int *pBuffer, DWORD lSampleCount, LPLONG lpMin, LPLONG lpMax)
 //------------------------------------------------------------------------------
 {
@@ -1701,7 +1707,7 @@ DWORD MPPASMCALL X86_Convert32To8(LPVOID lp8, int *pBuffer, DWORD lSampleCount,
 #endif //MSC_VER, else
 
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 // Clip and convert to 16 bit
 __declspec(naked) DWORD MPPASMCALL X86_Convert32To16(LPVOID lp16, int *pBuffer, DWORD lSampleCount, LPLONG lpMin, LPLONG lpMax)
 //------------------------------------------------------------------------------
@@ -1794,7 +1800,7 @@ DWORD MPPASMCALL X86_Convert32To16(LPVOID lp16, int *pBuffer, DWORD lSampleCount
 }
 #endif //MSC_VER, else
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 // Clip and convert to 24 bit
 __declspec(naked) DWORD MPPASMCALL X86_Convert32To24(LPVOID lp16, int *pBuffer, DWORD lSampleCount, LPLONG lpMin, LPLONG lpMax)
 //------------------------------------------------------------------------------
@@ -1887,13 +1893,13 @@ DWORD MPPASMCALL X86_Convert32To24(LPVOID lp16, int *pBuffer, DWORD lSampleCount
 			vumax = n;
 		p = n >> (8-MIXING_ATTENUATION) ; // 24-bit signed
 #ifdef WORDS_BIGENDIAN
-		buf[i*3+0] = p & 0xFF0000 >> 24;
-		buf[i*3+1] = p & 0x00FF00 >> 16 ;
-		buf[i*3+2] = p & 0x0000FF ;
+		buf[i*3+0] = (p >> 16) & 0xFF;
+		buf[i*3+1] = (p >> 8)  & 0xFF;
+		buf[i*3+2] = (p >> 0)  & 0xFF;
 #else
-		buf[i*3+0] = p & 0x0000FF ;
-		buf[i*3+1] = p & 0x00FF00 >> 16;
-		buf[i*3+2] = p & 0xFF0000 >> 24;
+		buf[i*3+0] = (p >> 0)  & 0xFF;
+		buf[i*3+1] = (p >> 8)  & 0xFF;
+		buf[i*3+2] = (p >> 16) & 0xFF;
 #endif
 	}
 	*lpMin = vumin;
@@ -1902,7 +1908,7 @@ DWORD MPPASMCALL X86_Convert32To24(LPVOID lp16, int *pBuffer, DWORD lSampleCount
 }
 #endif
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 // Clip and convert to 32 bit
 __declspec(naked) DWORD MPPASMCALL X86_Convert32To32(LPVOID lp16, int *pBuffer, DWORD lSampleCount, LPLONG lpMin, LPLONG lpMax)
 //------------------------------------------------------------------------------
@@ -1992,7 +1998,7 @@ DWORD MPPASMCALL X86_Convert32To32(LPVOID lp16, int *pBuffer, DWORD lSampleCount
 #endif
 
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 void MPPASMCALL X86_InitMixBuffer(int *pBuffer, UINT nSamples)
 //------------------------------------------------------------
 {
@@ -2034,7 +2040,7 @@ void MPPASMCALL X86_InitMixBuffer(int *pBuffer, UINT nSamples)
 #endif
 
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 __declspec(naked) void MPPASMCALL X86_InterleaveFrontRear(int *pFrontBuf, int *pRearBuf, DWORD nSamples)
 //------------------------------------------------------------------------------
 {
@@ -2079,7 +2085,7 @@ void MPPASMCALL X86_InterleaveFrontRear(int *pFrontBuf, int *pRearBuf, DWORD nSa
 #endif
 
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 VOID MPPASMCALL X86_MonoFromStereo(int *pMixBuf, UINT nSamples)
 //-------------------------------------------------------------
 {
@@ -2116,7 +2122,7 @@ VOID MPPASMCALL X86_MonoFromStereo(int *pMixBuf, UINT nSamples)
 #define OFSDECAYMASK	0xFF
 
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 void MPPASMCALL X86_StereoFill(int *pBuffer, UINT nSamples, LPLONG lpROfs, LPLONG lpLOfs)
 //------------------------------------------------------------------------------
 {
@@ -2217,7 +2223,7 @@ void MPPASMCALL X86_StereoFill(int *pBuffer, UINT nSamples, LPLONG lpROfs, LPLON
 }
 #endif
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 void MPPASMCALL X86_EndChannelOfs(MODCHANNEL *pChannel, int *pBuffer, UINT nSamples)
 //------------------------------------------------------------------------------
 {
@@ -2291,7 +2297,7 @@ void MPPASMCALL X86_EndChannelOfs(MODCHANNEL *pChannel, int *pBuffer, UINT nSamp
 #define MIXING_LIMITMAX		(0x08100000)
 #define MIXING_LIMITMIN		(-MIXING_LIMITMAX)
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 __declspec(naked) UINT MPPASMCALL X86_AGC(int *pBuffer, UINT nSamples, UINT nAGC)
 //------------------------------------------------------------------------------
 {
@@ -2327,7 +2333,6 @@ agcupdate:
 	jmp agcrecover
 	}
 }
-
 #pragma warning (default:4100)
 #else
 // Version for GCC
@@ -2378,11 +2383,9 @@ void CSoundFile::ProcessAGC(int count)
 }
 
 
-
 void CSoundFile::ResetAGC()
 //-------------------------
 {
 	gnAGC = AGC_UNITY;
 }
-
 #endif // NO_AGC
diff --git a/src/libmodplug/it_defs.h b/src/libmodplug/it_defs.h
index 89cb456..43fb944 100644
--- a/src/libmodplug/it_defs.h
+++ b/src/libmodplug/it_defs.h
@@ -128,7 +128,9 @@ typedef struct ITSAMPLESTRUCT
 
 #pragma pack()
 
-extern BYTE autovibit2xm[8];
-extern BYTE autovibxm2it[8];
+#if 0/* made these two static to load_it.cpp */
+extern const BYTE autovibit2xm[8];
+extern const BYTE autovibxm2it[8];
+#endif
 
 #endif
diff --git a/src/libmodplug/sndfile.h b/src/libmodplug/sndfile.h
index c009265..a638d2d 100644
--- a/src/libmodplug/sndfile.h
+++ b/src/libmodplug/sndfile.h
@@ -43,7 +43,6 @@ typedef const BYTE * LPCBYTE;
 #define MAX_EQ_BANDS		6
 #define MAX_MIXPLUGINS		8
 
-
 #define MOD_TYPE_NONE		0x00
 #define MOD_TYPE_MOD		0x01
 #define MOD_TYPE_S3M		0x02
@@ -74,8 +73,6 @@ typedef const BYTE * LPCBYTE;
 #define MOD_TYPE_UMX		0x80000000 // Fake type
 #define MAX_MODTYPE		24
 
-
-
 // Channel flags:
 // Bits 0-7:	Sample Flags
 #define CHN_16BIT               0x01
@@ -108,7 +105,6 @@ typedef const BYTE * LPCBYTE;
 #define CHN_REVERB              0x4000000
 #define CHN_NOREVERB		0x8000000
 
-
 #define ENV_VOLUME              0x0001
 #define ENV_VOLSUSTAIN		0x0002
 #define ENV_VOLLOOP             0x0004
@@ -157,7 +153,6 @@ typedef const BYTE * LPCBYTE;
 #define CMD_SETENVPOSITION		30
 #define CMD_MIDI                        31
 
-
 // Volume Column commands
 #define VOLCMD_VOLUME			1
 #define VOLCMD_PANNING			2
@@ -278,7 +273,6 @@ typedef const BYTE * LPCBYTE;
 #define SNDMIX_NOBACKWARDJUMPS	0x40000
 #define SNDMIX_MAXDEFAULTPAN	0x80000	// Used by the MOD loader
 
-
 // Reverb Types (GM2 Presets)
 enum {
 	REVERBTYPE_SMALLROOM,
@@ -290,7 +284,6 @@ enum {
 	NUM_REVERBTYPES
 };
 
-
 enum {
 	SRCMODE_NEAREST,
 	SRCMODE_LINEAR,
@@ -299,7 +292,6 @@ enum {
 	NUM_SRC_MODES
 };
 
-
 // Sample Struct
 typedef struct _MODINSTRUMENT
 {
@@ -320,7 +312,6 @@ typedef struct _MODINSTRUMENT
 	CHAR name[22];
 } MODINSTRUMENT;
 
-
 // Instrument Struct
 typedef struct _INSTRUMENTHEADER
 {
@@ -369,7 +360,6 @@ typedef struct _INSTRUMENTHEADER
 	CHAR filename[12];
 } INSTRUMENTHEADER;
 
-
 // Channel Struct
 typedef struct _MODCHANNEL
 {
@@ -427,11 +417,10 @@ typedef struct _MODCHANNEL
 	BYTE nRowNote, nRowInstr;
 	BYTE nRowVolCmd, nRowVolume;
 	BYTE nRowCommand, nRowParam;
-	BYTE nLeftVU, nRightVU;
+	BYTE nLeftVU, nRightVU; /* NOT USED! */
 	BYTE nActiveMacro, nPadding;
 } MODCHANNEL;
 
-
 typedef struct _MODCHANNELSETTINGS
 {
 	UINT nPan;
@@ -441,7 +430,6 @@ typedef struct _MODCHANNELSETTINGS
         char szName[MAX_CHANNELNAME];        // changed from CHAR
 } MODCHANNELSETTINGS;
 
-
 typedef struct _MODCOMMAND
 {
 	BYTE note;
@@ -456,7 +444,7 @@ typedef struct _MODCOMMAND
 // Mix Plugins
 #define MIXPLUG_MIXREADY			0x01	// Set when cleared
 
-class MODPLUG_EXPORT IMixPlugin
+class MODPLUG_EXPORTPP IMixPlugin
 {
 public:
 	virtual ~IMixPlugin() {};
@@ -520,7 +508,6 @@ enum {
 	MIDIOUT_PROGRAM,
 };
 
-
 typedef struct MODMIDICFG
 {
         char szMidiGlb[9*32];      // changed from CHAR
@@ -533,9 +520,8 @@ typedef struct MODMIDICFG
 typedef VOID (* LPSNDMIXHOOKPROC)(int *, unsigned long, unsigned long); // buffer, samples, channels
 
 
-
 //==============
-class MODPLUG_EXPORT CSoundFile
+class MODPLUG_EXPORTPP CSoundFile
 //==============
 {
 public:	// Static Members
@@ -651,7 +637,6 @@ public:
 	BOOL ReadAMF(LPCBYTE lpStream, DWORD dwMemLength);
 	BOOL ReadMT2(LPCBYTE lpStream, DWORD dwMemLength);
 	BOOL ReadPSM(LPCBYTE lpStream, DWORD dwMemLength);
-	BOOL ReadJ2B(LPCBYTE lpStream, DWORD dwMemLength);
 	BOOL ReadUMX(LPCBYTE lpStream, DWORD dwMemLength);
 	BOOL ReadABC(LPCBYTE lpStream, DWORD dwMemLength);
 	BOOL TestABC(LPCBYTE lpStream, DWORD dwMemLength);
@@ -660,20 +645,9 @@ public:
 	BOOL ReadPAT(LPCBYTE lpStream, DWORD dwMemLength);
 	BOOL TestPAT(LPCBYTE lpStream, DWORD dwMemLength);
 	// Save Functions
-#ifndef MODPLUG_NO_FILESAVE
-	UINT WriteSample(FILE *f, MODINSTRUMENT *pins, UINT nFlags, UINT nMaxLen=0);
-	BOOL SaveXM(LPCSTR lpszFileName, UINT nPacking=0);
-	BOOL SaveS3M(LPCSTR lpszFileName, UINT nPacking=0);
-	BOOL SaveMod(LPCSTR lpszFileName, UINT nPacking=0);
-	BOOL SaveIT(LPCSTR lpszFileName, UINT nPacking=0);
-#endif // MODPLUG_NO_FILESAVE
 	// MOD Convert function
-	UINT GetBestSaveFormat() const;
-	UINT GetSaveFormats() const;
 	void ConvertModCommand(MODCOMMAND *) const;
 	void S3MConvert(MODCOMMAND *m, BOOL bIT) const;
-	void S3MSaveConvert(UINT *pcmd, UINT *pprm, BOOL bIT) const;
-	WORD ModSaveCommand(const MODCOMMAND *m, BOOL bXM) const;
 
 public:
 	// Real-time sound functions
@@ -759,8 +733,7 @@ public:
 	BOOL IsValidBackwardJump(UINT nStartOrder, UINT nStartRow, UINT nJumpOrder, UINT nJumpRow) const;
 	// Read/Write sample functions
 	signed char GetDeltaValue(signed char prev, UINT n) const { return (signed char)(prev + CompressionTable[n & 0x0F]); }
-	UINT PackSample(int &sample, int next);
-	BOOL CanPackSample(LPSTR pSample, UINT nLen, UINT nPacking, BYTE *result=NULL);
+
 	UINT ReadSample(MODINSTRUMENT *pIns, UINT nFlags, LPCSTR pMemFile, DWORD dwMemLength);
 	BOOL DestroySample(UINT nSample);
 	BOOL DestroyInstrument(UINT nInstr);
@@ -803,11 +776,6 @@ public:
 	static UINT Normalize24BitBuffer(LPBYTE pbuffer, UINT cbsizebytes, DWORD lmax24, DWORD dwByteInc);
 };
 
-
-// inline DWORD BigEndian(DWORD x) { return ((x & 0xFF) << 24) | ((x & 0xFF00) << 8) | ((x & 0xFF0000) >> 8) | ((x & 0xFF000000) >> 24); }
-// inline WORD BigEndianW(WORD x) { return (WORD)(((x >> 8) & 0xFF) | ((x << 8) & 0xFF00)); }
-
-
 //////////////////////////////////////////////////////////
 // WAVE format information
 
@@ -848,7 +816,6 @@ typedef struct WAVEFILEHEADER
 	DWORD id_WAVE;
 } WAVEFILEHEADER;
 
-
 typedef struct WAVEFORMATHEADER
 {
 	DWORD id_fmt;		// "fmt "
@@ -861,14 +828,12 @@ typedef struct WAVEFORMATHEADER
 	WORD bitspersample;	// bits per sample (8/16)
 } WAVEFORMATHEADER;
 
-
 typedef struct WAVEDATAHEADER
 {
 	DWORD id_data;		// "data"
 	DWORD length;		// length of data
 } WAVEDATAHEADER;
 
-
 typedef struct WAVESMPLHEADER
 {
 	// SMPL
@@ -885,7 +850,6 @@ typedef struct WAVESMPLHEADER
 	DWORD cbSamplerData;
 } WAVESMPLHEADER;
 
-
 typedef struct SAMPLELOOPSTRUCT
 {
 	DWORD dwIdentifier;
@@ -896,14 +860,12 @@ typedef struct SAMPLELOOPSTRUCT
 	DWORD dwPlayCount;		// Loop Count, 0=infinite
 } SAMPLELOOPSTRUCT;
 
-
 typedef struct WAVESAMPLERINFO
 {
 	WAVESMPLHEADER wsiHdr;
 	SAMPLELOOPSTRUCT wsiLoops[2];
 } WAVESAMPLERINFO;
 
-
 typedef struct WAVELISTHEADER
 {
 	DWORD list_id;	// "LIST" -> 0x5453494C
@@ -911,7 +873,6 @@ typedef struct WAVELISTHEADER
 	DWORD info;		// "INFO"
 } WAVELISTHEADER;
 
-
 typedef struct WAVEEXTRAHEADER
 {
 	DWORD xtra_id;	// "xtra"	-> 0x61727478
@@ -943,7 +904,7 @@ typedef struct WAVEEXTRAHEADER
 #define AGC_UNITY			(1 << AGC_PRECISION)
 
 // Calling conventions
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 #define MPPASMCALL	__cdecl
 #define MPPFASTCALL	__fastcall
 #else
@@ -958,6 +919,9 @@ int _muldiv(long a, long b, long c);
 int _muldivr(long a, long b, long c);
 
 
+// inline DWORD BigEndian(DWORD x) { return ((x & 0xFF) << 24) | ((x & 0xFF00) << 8) | ((x & 0xFF0000) >> 8) | ((x & 0xFF000000) >> 24); }
+// inline WORD BigEndianW(WORD x) { return (WORD)(((x >> 8) & 0xFF) | ((x << 8) & 0xFF00)); }
+
 // Byte swapping functions from the GNU C Library and libsdl
 
 /* Swap bytes in 16 bit value.  */
diff --git a/src/libmodplug/stdafx.h b/src/libmodplug/stdafx.h
index d45d949..219bc7d 100644
--- a/src/libmodplug/stdafx.h
+++ b/src/libmodplug/stdafx.h
@@ -23,35 +23,43 @@
 
 /* disable AGC and FILESAVE for all targets for uniformity. */
 #define NO_AGC
-#define MODPLUG_NO_FILESAVE
+/*#define NO_FILTER */
 
 #ifdef _WIN32
 
-#ifdef MSC_VER
+#ifdef _MSC_VER
 #pragma warning (disable:4201)
 #pragma warning (disable:4514)
 #endif
 
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
-#include <windowsx.h>
-#include <mmsystem.h>
+#include <mmsystem.h> /* for WAVE_FORMAT_PCM */
 #include <stdio.h>
 #include <malloc.h>
+#if defined(_MSC_VER) && (_MSC_VER < 1600)
+typedef signed char    int8_t;
+typedef signed short   int16_t;
+typedef signed int     int32_t;
+typedef unsigned char  uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int   uint32_t;
+#else
 #include <stdint.h>
+#endif
 
-#define srandom(_seed)  srand(_seed)
-#define random()        rand()
-#define sleep(_ms)      Sleep(_ms)
+#define sleep(_ms)      Sleep(_ms * 1000)
 
-inline void ProcessPlugins(int n) {}
+inline void ProcessPlugins(int n) { (void)n; }
 
 #undef strcasecmp
 #undef strncasecmp
 #define strcasecmp(a,b)     _stricmp(a,b)
 #define strncasecmp(a,b,c)  _strnicmp(a,b,c)
 
+#if defined(_MSC_VER) || defined(__MINGW32__)
 #define HAVE_SINF 1
+#endif
 
 #ifndef isblank
 #define isblank(c) ((c) == ' ' || (c) == '\t')
@@ -80,7 +88,7 @@ typedef uint32_t* LPDWORD;
 typedef uint16_t WORD;
 typedef uint8_t BYTE;
 typedef uint8_t* LPBYTE;
-typedef bool BOOL;
+typedef bool BOOL; /* FIXME: must be 'int' */
 typedef char* LPSTR;
 typedef void* LPVOID;
 typedef uint16_t* LPWORD;
@@ -88,12 +96,6 @@ typedef const char* LPCSTR;
 typedef void* PVOID;
 typedef void VOID;
 
-inline LONG MulDiv (long a, long b, long c)
-{
-/*if (!c) return 0;*/
-  return ((uint64_t) a * (uint64_t) b ) / c;
-}
-
 #define LPCTSTR LPCSTR
 #define lstrcpyn strncpy
 #define lstrcpy strcpy
@@ -102,17 +104,7 @@ inline LONG MulDiv (long a, long b, long c)
 
 #define WAVE_FORMAT_PCM 1
 
-#define  GHND   0
-#define GlobalFreePtr(p) free((void *)(p))
-inline int8_t * GlobalAllocPtr(unsigned int, size_t size)
-{
-  int8_t * p = (int8_t *) malloc(size);
-
-  if (p != NULL) memset(p, 0, size);
-  return p;
-}
-
-inline void ProcessPlugins(int n) {}
+inline void ProcessPlugins(int n) { (void)n; }
 
 #ifndef FALSE
 #define FALSE	false
@@ -132,10 +124,22 @@ inline void ProcessPlugins(int n) {}
 # else
 #   define MODPLUG_EXPORT __declspec(dllimport)			/* using libmodplug dll for windows */
 # endif
+#elif defined(__OS2__) && defined(__WATCOMC__)
+# if defined(MODPLUG_BUILD) && defined(__SW_BD)		/* building libmodplug as a dll for os/2 */
+#   define MODPLUG_EXPORT __declspec(dllexport)
+# else
+#   define MODPLUG_EXPORT					/* using dll or static libmodplug for os/2 */
+# endif
 #elif defined(MODPLUG_BUILD) && defined(SYM_VISIBILITY)
 #   define MODPLUG_EXPORT __attribute__((visibility("default")))
 #else
 #define MODPLUG_EXPORT
 #endif
 
+#if !defined(NO_CXX_EXPORTS)
+#define MODPLUG_EXPORTPP	MODPLUG_EXPORT
+#else
+#define MODPLUG_EXPORTPP
+#endif
+
 #endif
diff --git a/src/load_669.cpp b/src/load_669.cpp
index c275615..236e07d 100644
--- a/src/load_669.cpp
+++ b/src/load_669.cpp
@@ -17,7 +17,7 @@
 typedef struct tagFILEHEADER669
 {
 	WORD sig;				// 'if' or 'JN'
-        signed char songmessage[108];	// Song Message
+	signed char songmessage[108];	// Song Message
 	BYTE samples;			// number of samples (1-64)
 	BYTE patterns;			// number of patterns (1-128)
 	BYTE restartpos;
@@ -26,7 +26,6 @@ typedef struct tagFILEHEADER669
 	BYTE breaks[128];
 } FILEHEADER669;
 
-
 typedef struct tagSAMPLE669
 {
 	BYTE filename[13];
@@ -35,7 +34,7 @@ typedef struct tagSAMPLE669
 	BYTE loopend[4];
 } SAMPLE669;
 
-DWORD lengthArrayToDWORD(const BYTE length[4]) {
+static DWORD lengthArrayToDWORD(const BYTE length[4]) {
 	DWORD len = (length[3] << 24) +
 		(length[2] << 16) +
 		(length[1] << 8) +
@@ -156,9 +155,9 @@ BOOL CSoundFile::Read669(const BYTE *lpStream, DWORD dwMemLength)
 					case 0x04:	command = CMD_VIBRATO; param |= 0x40; break;
 					case 0x05:	if (param) command = CMD_SPEED; else command = 0; param += 2; break;
 					case 0x06:	if (param == 0) { command = CMD_PANNINGSLIDE; param = 0xFE; }
-								else if (param == 1) { command = CMD_PANNINGSLIDE; param = 0xEF; }
-								else command = 0;
-								break;
+							else if (param == 1) { command = CMD_PANNINGSLIDE; param = 0xEF; }
+							else command = 0;
+							break;
 					default:	command = 0;
 					}
 					if (command)
diff --git a/src/load_abc.cpp b/src/load_abc.cpp
index ee79f39..fe5e74c 100644
--- a/src/load_abc.cpp
+++ b/src/load_abc.cpp
@@ -31,15 +31,25 @@
 #include <math.h>
 #include <ctype.h>
 #ifndef _WIN32
-#include <unistd.h> // for sleep
-#endif // _WIN32
+#include <unistd.h>  /* sleep() */
+#endif
 
 #include "stdafx.h"
 #include "sndfile.h"
 
+#ifndef MIDIFMT_SUPPORT
+BOOL CSoundFile::TestABC(const BYTE *lpStream, DWORD dwMemLength) {
+	return FALSE;
+}
+BOOL CSoundFile::ReadABC(const BYTE *lpStream, DWORD dwMemLength) {
+	return FALSE;
+}
+
+#else
+
 #include "load_pat.h"
 
-#if _MSC_VER >= 1600
+#if defined(_MSC_VER) && (_MSC_VER >= 1300)
 #define putenv _putenv
 #define strdup _strdup
 #endif
@@ -256,16 +266,6 @@ static void abc_add_setjumploop(ABCHANDLE *h, ABCTRACK *tp, uint32_t tracktime,
 static uint32_t abc_pattracktime(ABCHANDLE *h, uint32_t tracktime);
 static int abc_patno(ABCHANDLE *h, uint32_t tracktime);
 
-#ifndef HAVE_SETENV
-static void setenv(const char *name, const char *value, int overwrite)
-{
-	int len = strlen(name)+1+strlen(value)+1;
-	char *str = (char *)malloc(len);
-	sprintf(str, "%s=%s", name, value);
-	putenv(str);
-	free(str);
-}
-#endif
 
 static int abc_isvalidchar(char c) {
 	return(isalpha(c) || isdigit(c) || isspace(c) || c == '%' || c == ':');
@@ -403,7 +403,7 @@ static void abc_dumptracks(ABCHANDLE *h, const char *p)
 	}
 }
 
-#if defined(WIN32) && defined(_mm_free)
+#if defined(_WIN32) && defined(_mm_free)
 #undef _mm_free
 #endif
 
@@ -1484,7 +1484,7 @@ static void	abc_add_chord(const char *p, ABCHANDLE *h, ABCTRACK *tp, uint32_t tr
 			d[chordnote] = i;
 			break;
 		}
-	p++;
+	if (*p) p++;
 	switch(*p) {
 		case 'b':
 			d[chordnote]--;
@@ -1506,7 +1506,7 @@ static void	abc_add_chord(const char *p, ABCHANDLE *h, ABCTRACK *tp, uint32_t tr
 				d[chordbase] = i;
 				break;
 			}
-		p++;
+		if (*p) p++;
 		switch(*p) {
 			case 'b':
 				d[chordbase]--;
@@ -2345,9 +2345,9 @@ BOOL CSoundFile::TestABC(const BYTE *lpStream, DWORD dwMemLength)
 // =====================================================================================
 static ABCHANDLE *ABC_Init(void)
 {
+	static char buf[40];
 	ABCHANDLE   *retval;
 	char *p;
-	char buf[10];
 	retval = (ABCHANDLE *)calloc(1,sizeof(ABCHANDLE));
 	if( !retval ) return NULL;
 	retval->track       = NULL;
@@ -2365,16 +2365,16 @@ static ABCHANDLE *ABC_Init(void)
 			retval->pickrandom = atoi(p);
 		if( *p == '-' ) {
 			retval->pickrandom = atoi(p+1)-1; // xmms preloads the file
-			sprintf(buf,"-%ld",retval->pickrandom+2);
-			setenv(ABC_ENV_NORANDOMPICK, buf, 1);
+			sprintf(buf,"%s=-%ld",ABC_ENV_NORANDOMPICK,retval->pickrandom+2);
+			putenv(buf);
 		}
 	}
 	else {
-		srandom((uint32_t)time(0));	// initialize random generator with seed
-		retval->pickrandom = 1+(int)(10000.0*random()/(RAND_MAX+1.0));
+		srand((unsigned int)time(0));	// initialize random generator with seed
+		retval->pickrandom = 1+(int)(10000.0*rand()/(RAND_MAX+1.0));
 		// can handle pickin' from songbooks with 10.000 songs
-		sprintf(buf,"-%ld",retval->pickrandom); // xmms preloads the file
-		setenv(ABC_ENV_NORANDOMPICK, buf, 1);
+		sprintf(buf,"%s=-%ld",ABC_ENV_NORANDOMPICK,retval->pickrandom); // xmms preloads the file
+		putenv(buf);
 	}
 	return retval;
 }
@@ -2643,10 +2643,11 @@ static int ABC_ReadPatterns(MODCOMMAND *pattern[], WORD psize[], ABCHANDLE *h, i
 static int ABC_Key(const char *p)
 {
 	int i,j;
-	char c[8] = {}; // initialize all to zero.
+	char c[8];
 	const char *q;
 	while( isspace(*p) ) p++;
 	q = p;
+	memset(c, 0, 8);
 	for( i=0; i<8 && *p && *p != ']'; p++ ) {
 		if( isspace(*p) ) {
 			while( isspace(*p) ) p++;
@@ -2939,9 +2940,10 @@ static void abc_MIDI_voice(const char *p, ABCTRACK *tp, ABCHANDLE *h)
 static void abc_MIDI_chordname(const char *p)
 {
 	char name[20];
-	int i, notes[6] = {};
+	int i;
 
-	for( ; *p && isspace(*p); p++ ) ;
+	for(; *p && isspace(*p); p++)
+		;
 	i = 0;
 	while ((i < 19) && (*p != ' ') && (*p != '\0')) {
 		name[i] = *p;
@@ -2953,9 +2955,12 @@ static void abc_MIDI_chordname(const char *p)
 		abc_message("Failure: Bad format for chordname command, %s", p);
 	}
 	else {
+		int notes[6];
 		i = 0;
+		memset(notes, 0, sizeof(notes));
 		while ((i < 6) && isspace(*p)) {
-			for( ; *p && isspace(*p); p++ ) ;
+			for(; *p && isspace(*p); p++)
+				;
 			p += abc_getnumber(p, &notes[i]);
 			i = i + 1;
 		}
@@ -4878,3 +4883,4 @@ BOOL CSoundFile::ReadABC(const uint8_t *lpStream, DWORD dwMemLength)
 	ABC_Cleanup(h);	// we dont need it anymore
 	return 1;
 }
+#endif // MIDIFMT_SUPPORT
diff --git a/src/load_amf.cpp b/src/load_amf.cpp
index c560a29..82ea867 100644
--- a/src/load_amf.cpp
+++ b/src/load_amf.cpp
@@ -44,7 +44,6 @@ typedef struct _AMFSAMPLE
 	UCHAR volume;
 } AMFSAMPLE;
 
-
 #pragma pack()
 
 
@@ -52,7 +51,7 @@ typedef struct _AMFSAMPLE
 extern void Log(LPCSTR, ...);
 #endif
 
-VOID AMF_Unpack(MODCOMMAND *pPat, const BYTE *pTrack, UINT nRows, UINT nChannels)
+static VOID AMF_Unpack(MODCOMMAND *pPat, const BYTE *pTrack, UINT nRows, UINT nChannels)
 //-------------------------------------------------------------------------------
 {
 	UINT lastinstr = 0;
@@ -163,7 +162,6 @@ VOID AMF_Unpack(MODCOMMAND *pPat, const BYTE *pTrack, UINT nRows, UINT nChannels
 }
 
 
-
 BOOL CSoundFile::ReadAMF(LPCBYTE lpStream, const DWORD dwMemLength)
 //-----------------------------------------------------------
 {
diff --git a/src/load_dbm.cpp b/src/load_dbm.cpp
index 9aff94b..8bc9c9b 100644
--- a/src/load_dbm.cpp
+++ b/src/load_dbm.cpp
@@ -249,7 +249,7 @@ BOOL CSoundFile::ReadDBM(const BYTE *lpStream, DWORD dwMemLength)
 					MODCOMMAND *m = AllocatePattern(nRows, m_nChannels);
 					if (m)
 					{
-						LPBYTE pkdata = (LPBYTE)&pph->patterndata;
+						LPBYTE pkdata = (LPBYTE)pph->patterndata;
 						UINT row = 0;
 						UINT i = 0;
 
@@ -365,4 +365,3 @@ BOOL CSoundFile::ReadDBM(const BYTE *lpStream, DWORD dwMemLength)
 	}
 	return TRUE;
 }
-
diff --git a/src/load_dmf.cpp b/src/load_dmf.cpp
index 7bfca22..1d4f8a7 100644
--- a/src/load_dmf.cpp
+++ b/src/load_dmf.cpp
@@ -279,7 +279,8 @@ BOOL CSoundFile::ReadDMF(const BYTE *lpStream, DWORD dwMemLength)
 								case 8: cmd.command = CMD_VIBRATO; cmd.param = eval; break;
 								// 12: Note cut
 								case 12: if (eval & 0xe0) { cmd.command = CMD_S3MCMDEX; cmd.param = (eval>>5)|0xc0; }
-										else if (!cmd.note) { cmd.note = 0xfe; } break;
+									 else if (!cmd.note) { cmd.note = 0xfe; }
+									 break;
 								#ifdef DMFLOG
 								default: Log("FX2: %02X.%02X\n", efx, eval);
 								#endif
@@ -509,7 +510,7 @@ typedef struct DMF_HTREE
 
 
 // DMF Huffman ReadBits
-BYTE DMFReadBits(DMF_HTREE *tree, UINT nbits)
+static BYTE DMFReadBits(DMF_HTREE *tree, UINT nbits)
 //-------------------------------------------
 {
 	BYTE x = 0, bitv = 1;
@@ -534,7 +535,7 @@ BYTE DMFReadBits(DMF_HTREE *tree, UINT nbits)
 // tree: [8-bit value][12-bit index][12-bit index] = 32-bit
 //
 
-void DMFNewNode(DMF_HTREE *tree)
+static void DMFNewNode(DMF_HTREE *tree)
 //------------------------------
 {
 	BYTE isleft, isright;
diff --git a/src/load_it.cpp b/src/load_it.cpp
index 4c6a4e1..32be603 100644
--- a/src/load_it.cpp
+++ b/src/load_it.cpp
@@ -15,26 +15,13 @@
 #pragma warning(disable:4244)
 #endif
 
+static const
 BYTE autovibit2xm[8] =
 { 0, 3, 1, 4, 2, 0, 0, 0 };
 
-BYTE autovibxm2it[8] =
-{ 0, 2, 4, 1, 3, 0, 0, 0 };
-
 //////////////////////////////////////////////////////////
 // Impulse Tracker IT file support
 
-// for conversion of XM samples
-extern WORD XMPeriodTable[96+8];
-extern UINT XMLinearTable[768];
-
-static inline UINT ConvertVolParam(UINT value)
-//--------------------------------------------
-{
-	return (value > 9)  ? 9 : value;
-}
-
-
 BOOL CSoundFile::ITInstrToMPT(const void *p, INSTRUMENTHEADER *penv, UINT trkvers)
 //--------------------------------------------------------------------------------
 {
@@ -165,6 +152,7 @@ BOOL CSoundFile::ReadIT(const BYTE *lpStream, DWORD dwMemLength)
 	DWORD patpos[MAX_PATTERNS];
 	BYTE chnmask[64], channels_used[64];
 	MODCOMMAND lastvalue[64];
+	UINT j;
 
 	if ((!lpStream) || (dwMemLength < sizeof(ITFILEHEADER))) return FALSE;
 	ITFILEHEADER pifh = *(ITFILEHEADER *)lpStream;
@@ -237,7 +225,7 @@ BOOL CSoundFile::ReadIT(const BYTE *lpStream, DWORD dwMemLength)
 	if (inspossize > MAX_INSTRUMENTS) inspossize = MAX_INSTRUMENTS;
 	inspossize <<= 2;
 	memcpy(inspos, lpStream+dwMemPos, inspossize);
-	for (UINT j=0; j < (inspossize>>2); j++)
+	for (j=0; j < (inspossize>>2); j++)
 	{
 	       inspos[j] = bswapLE32(inspos[j]);
 	}
@@ -248,7 +236,7 @@ BOOL CSoundFile::ReadIT(const BYTE *lpStream, DWORD dwMemLength)
 	if (smppossize > MAX_SAMPLES) smppossize = MAX_SAMPLES;
 	smppossize <<= 2;
 	memcpy(smppos, lpStream+dwMemPos, smppossize);
-	for (UINT j=0; j < (smppossize>>2); j++)
+	for (j=0; j < (smppossize>>2); j++)
 	{
 	       smppos[j] = bswapLE32(smppos[j]);
 	}
@@ -259,7 +247,7 @@ BOOL CSoundFile::ReadIT(const BYTE *lpStream, DWORD dwMemLength)
 	if (patpossize > MAX_PATTERNS) patpossize = MAX_PATTERNS;
 	patpossize <<= 2;
 	memcpy(patpos, lpStream+dwMemPos, patpossize);
-	for (UINT j=0; j < (patpossize>>2); j++)
+	for (j=0; j < (patpossize>>2); j++)
 	{
 	       patpos[j] = bswapLE32(patpos[j]);
 	}
@@ -592,593 +580,6 @@ BOOL CSoundFile::ReadIT(const BYTE *lpStream, DWORD dwMemLength)
 }
 
 
-#ifndef MODPLUG_NO_FILESAVE
-//#define SAVEITTIMESTAMP
-#ifdef _MSC_VER
-#pragma warning(disable:4100)
-#endif
-
-BOOL CSoundFile::SaveIT(LPCSTR lpszFileName, UINT nPacking)
-//---------------------------------------------------------
-{
-	DWORD dwPatNamLen, dwChnNamLen;
-	ITFILEHEADER header, writeheader;
-	ITINSTRUMENT iti, writeiti;
-	ITSAMPLESTRUCT itss;
-	BYTE smpcount[MAX_SAMPLES];
-	DWORD inspos[MAX_INSTRUMENTS];
-	DWORD patpos[MAX_PATTERNS];
-	DWORD smppos[MAX_SAMPLES];
-	DWORD dwPos = 0, dwHdrPos = 0, dwExtra = 2;
-	WORD patinfo[4];
-	BYTE chnmask[64];
-	BYTE buf[512];
-	MODCOMMAND lastvalue[64];
-	FILE *f;
-
-
-	if ((!lpszFileName) || ((f = fopen(lpszFileName, "wb")) == NULL)) return FALSE;
-	memset(inspos, 0, sizeof(inspos));
-	memset(patpos, 0, sizeof(patpos));
-	memset(smppos, 0, sizeof(smppos));
-	// Writing Header
-	memset(&header, 0, sizeof(header));
-	dwPatNamLen = 0;
-	dwChnNamLen = 0;
-	header.id = 0x4D504D49; // IMPM
-	lstrcpyn((char *)header.songname, m_szNames[0], 27);
-	header.reserved1 = 0x1004;
-	header.ordnum = 0;
-	while ((header.ordnum < MAX_ORDERS) && (Order[header.ordnum] < 0xFF)) header.ordnum++;
-	if (header.ordnum < MAX_ORDERS) Order[header.ordnum++] = 0xFF;
-	header.insnum = m_nInstruments;
-	header.smpnum = m_nSamples;
-	header.patnum = MAX_PATTERNS;
-	while ((header.patnum > 0) && (!Patterns[header.patnum-1])) header.patnum--;
-	header.cwtv = 0x217;
-	header.cmwt = 0x200;
-	header.flags = 0x0001;
-	header.special = 0x0006;
-	if (m_nInstruments) header.flags |= 0x04;
-	if (m_dwSongFlags & SONG_LINEARSLIDES) header.flags |= 0x08;
-	if (m_dwSongFlags & SONG_ITOLDEFFECTS) header.flags |= 0x10;
-	if (m_dwSongFlags & SONG_ITCOMPATMODE) header.flags |= 0x20;
-	if (m_dwSongFlags & SONG_EXFILTERRANGE) header.flags |= 0x1000;
-	header.globalvol = m_nDefaultGlobalVolume >> 1;
-	header.mv = m_nSongPreAmp;
-	// clip song pre-amp values (between 0x20 and 0x7f)
-	if (header.mv < 0x20) header.mv = 0x20;
-	if (header.mv > 0x7F) header.mv = 0x7F;
-	header.speed = m_nDefaultSpeed;
-	header.tempo = m_nDefaultTempo;
-	header.sep = m_nStereoSeparation;
-	dwHdrPos = sizeof(header) + header.ordnum;
-	// Channel Pan and Volume
-	memset(header.chnpan, 0xFF, 64);
-	memset(header.chnvol, 64, 64);
-	for (UINT ich=0; ich<m_nChannels; ich++)
-	{
-		header.chnpan[ich] = ChnSettings[ich].nPan >> 2;
-		if (ChnSettings[ich].dwFlags & CHN_SURROUND) header.chnpan[ich] = 100;
-		header.chnvol[ich] = ChnSettings[ich].nVolume;
-		if (ChnSettings[ich].dwFlags & CHN_MUTE) header.chnpan[ich] |= 0x80;
-		if (ChnSettings[ich].szName[0])
-		{
-			dwChnNamLen = (ich+1) * MAX_CHANNELNAME;
-		}
-	}
-	if (dwChnNamLen) dwExtra += dwChnNamLen + 8;
-#ifdef SAVEITTIMESTAMP
-	dwExtra += 8; // Time Stamp
-#endif
-	if (m_dwSongFlags & SONG_EMBEDMIDICFG)
-	{
-		header.flags |= 0x80;
-		header.special |= 0x08;
-		dwExtra += sizeof(MODMIDICFG);
-	}
-	// Pattern Names
-	if ((m_nPatternNames) && (m_lpszPatternNames))
-	{
-		dwPatNamLen = m_nPatternNames * MAX_PATTERNNAME;
-		while ((dwPatNamLen >= MAX_PATTERNNAME) && (!m_lpszPatternNames[dwPatNamLen-MAX_PATTERNNAME])) dwPatNamLen -= MAX_PATTERNNAME;
-		if (dwPatNamLen < MAX_PATTERNNAME) dwPatNamLen = 0;
-		if (dwPatNamLen) dwExtra += dwPatNamLen + 8;
-	}
-	// Mix Plugins
-	dwExtra += SaveMixPlugins(NULL, TRUE);
-	// Comments
-	if (m_lpszSongComments)
-	{
-		header.special |= 1;
-		header.msglength = strlen(m_lpszSongComments)+1;
-		header.msgoffset = dwHdrPos + dwExtra + header.insnum*4 + header.patnum*4 + header.smpnum*4;
-	}
-	// Write file header
-	memcpy(&writeheader, &header, sizeof(header));
-
-	// Byteswap header information
-	writeheader.id = bswapLE32(writeheader.id);
-	writeheader.reserved1 = bswapLE16(writeheader.reserved1);
-	writeheader.ordnum = bswapLE16(writeheader.ordnum);
-	writeheader.insnum = bswapLE16(writeheader.insnum);
-	writeheader.smpnum = bswapLE16(writeheader.smpnum);
-	writeheader.patnum = bswapLE16(writeheader.patnum);
-	writeheader.cwtv = bswapLE16(writeheader.cwtv);
-	writeheader.cmwt = bswapLE16(writeheader.cmwt);
-	writeheader.flags = bswapLE16(writeheader.flags);
-	writeheader.special = bswapLE16(writeheader.special);
-	writeheader.msglength = bswapLE16(writeheader.msglength);
-	writeheader.msgoffset = bswapLE32(writeheader.msgoffset);
-	writeheader.reserved2 = bswapLE32(writeheader.reserved2);
-
-	fwrite(&writeheader, 1, sizeof(writeheader), f);
-
-	fwrite(Order, 1, header.ordnum, f);
-	if (header.insnum) fwrite(inspos, 4, header.insnum, f);
-	if (header.smpnum) fwrite(smppos, 4, header.smpnum, f);
-	if (header.patnum) fwrite(patpos, 4, header.patnum, f);
-	// Writing editor history information
-	{
-#ifdef SAVEITTIMESTAMP
-		SYSTEMTIME systime;
-		FILETIME filetime;
-		WORD timestamp[4];
-		WORD nInfoEx = 1;
-		memset(timestamp, 0, sizeof(timestamp));
-		fwrite(&nInfoEx, 1, 2, f);
-		GetSystemTime(&systime);
-		SystemTimeToFileTime(&systime, &filetime);
-		FileTimeToDosDateTime(&filetime, &timestamp[0], &timestamp[1]);
-		fwrite(timestamp, 1, 8, f);
-#else
-		WORD nInfoEx = 0;
-		fwrite(&nInfoEx, 1, 2, f);
-#endif
-	}
-	// Writing midi cfg
-	if (header.flags & 0x80)
-	{
-		fwrite(&m_MidiCfg, 1, sizeof(MODMIDICFG), f);
-	}
-	// Writing pattern names
-	if (dwPatNamLen)
-	{
-		DWORD d = bswapLE32(0x4d414e50);
-		UINT len= bswapLE32(dwPatNamLen);
-		fwrite(&d, 1, 4, f);
-		fwrite(&len, 1, 4, f);
-		fwrite(m_lpszPatternNames, 1, dwPatNamLen, f);
-	}
-	// Writing channel Names
-	if (dwChnNamLen)
-	{
-		DWORD d = bswapLE32(0x4d414e43);
-		UINT len= bswapLE32(dwChnNamLen);
-		fwrite(&d, 1, 4, f);
-		fwrite(&len, 1, 4, f);
-		UINT nChnNames = dwChnNamLen / MAX_CHANNELNAME;
-		for (UINT inam=0; inam<nChnNames; inam++)
-		{
-			fwrite(ChnSettings[inam].szName, 1, MAX_CHANNELNAME, f);
-		}
-	}
-	// Writing mix plugins info
-	SaveMixPlugins(f, FALSE);
-	// Writing song message
-	dwPos = dwHdrPos + dwExtra + (header.insnum + header.smpnum + header.patnum) * 4;
-	if (header.special & 1)
-	{
-		dwPos += strlen(m_lpszSongComments) + 1;
-		fwrite(m_lpszSongComments, 1, strlen(m_lpszSongComments)+1, f);
-	}
-	// Writing instruments
-	for (UINT nins=1; nins<=header.insnum; nins++)
-	{
-		memset(&iti, 0, sizeof(iti));
-		iti.id = 0x49504D49;	// "IMPI"
-		iti.trkvers = 0x211;
-		if (Headers[nins])
-		{
-			INSTRUMENTHEADER *penv = Headers[nins];
-			memset(smpcount, 0, sizeof(smpcount));
-			memcpy(iti.filename, penv->filename, 12);
-			memcpy(iti.name, penv->name, 26);
-			iti.mbank = penv->wMidiBank;
-			iti.mpr = penv->nMidiProgram;
-			iti.mch = penv->nMidiChannel;
-			iti.nna = penv->nNNA;
-			iti.dct = penv->nDCT;
-			iti.dca = penv->nDNA;
-			iti.fadeout = penv->nFadeOut >> 5;
-			iti.pps = penv->nPPS;
-			iti.ppc = penv->nPPC;
-			iti.gbv = (BYTE)(penv->nGlobalVol << 1);
-			iti.dfp = (BYTE)penv->nPan >> 2;
-			if (!(penv->dwFlags & ENV_SETPANNING)) iti.dfp |= 0x80;
-			iti.rv = penv->nVolSwing;
-			iti.rp = penv->nPanSwing;
-			iti.ifc = penv->nIFC;
-			iti.ifr = penv->nIFR;
-			iti.nos = 0;
-			for (UINT i=0; i<NOTE_MAX; i++) if (penv->Keyboard[i] < MAX_SAMPLES)
-			{
-				UINT smp = penv->Keyboard[i];
-				if ((smp) && (!smpcount[smp]))
-				{
-					smpcount[smp] = 1;
-					iti.nos++;
-				}
-				iti.keyboard[i*2] = penv->NoteMap[i] - 1;
-				iti.keyboard[i*2+1] = smp;
-			}
-			// Writing Volume envelope
-			if (penv->dwFlags & ENV_VOLUME) iti.volenv.flags |= 0x01;
-			if (penv->dwFlags & ENV_VOLLOOP) iti.volenv.flags |= 0x02;
-			if (penv->dwFlags & ENV_VOLSUSTAIN) iti.volenv.flags |= 0x04;
-			if (penv->dwFlags & ENV_VOLCARRY) iti.volenv.flags |= 0x08;
-			iti.volenv.num = (BYTE)penv->nVolEnv;
-			iti.volenv.lpb = (BYTE)penv->nVolLoopStart;
-			iti.volenv.lpe = (BYTE)penv->nVolLoopEnd;
-			iti.volenv.slb = penv->nVolSustainBegin;
-			iti.volenv.sle = penv->nVolSustainEnd;
-			// Writing Panning envelope
-			if (penv->dwFlags & ENV_PANNING) iti.panenv.flags |= 0x01;
-			if (penv->dwFlags & ENV_PANLOOP) iti.panenv.flags |= 0x02;
-			if (penv->dwFlags & ENV_PANSUSTAIN) iti.panenv.flags |= 0x04;
-			if (penv->dwFlags & ENV_PANCARRY) iti.panenv.flags |= 0x08;
-			iti.panenv.num = (BYTE)penv->nPanEnv;
-			iti.panenv.lpb = (BYTE)penv->nPanLoopStart;
-			iti.panenv.lpe = (BYTE)penv->nPanLoopEnd;
-			iti.panenv.slb = penv->nPanSustainBegin;
-			iti.panenv.sle = penv->nPanSustainEnd;
-			// Writing Pitch Envelope
-			if (penv->dwFlags & ENV_PITCH) iti.pitchenv.flags |= 0x01;
-			if (penv->dwFlags & ENV_PITCHLOOP) iti.pitchenv.flags |= 0x02;
-			if (penv->dwFlags & ENV_PITCHSUSTAIN) iti.pitchenv.flags |= 0x04;
-			if (penv->dwFlags & ENV_PITCHCARRY) iti.pitchenv.flags |= 0x08;
-			if (penv->dwFlags & ENV_FILTER) iti.pitchenv.flags |= 0x80;
-			iti.pitchenv.num = (BYTE)penv->nPitchEnv;
-			iti.pitchenv.lpb = (BYTE)penv->nPitchLoopStart;
-			iti.pitchenv.lpe = (BYTE)penv->nPitchLoopEnd;
-			iti.pitchenv.slb = (BYTE)penv->nPitchSustainBegin;
-			iti.pitchenv.sle = (BYTE)penv->nPitchSustainEnd;
-			// Writing Envelopes data
-			for (UINT ev=0; ev<25; ev++)
-			{
-				iti.volenv.data[ev*3] = penv->VolEnv[ev];
-				iti.volenv.data[ev*3+1] = penv->VolPoints[ev] & 0xFF;
-				iti.volenv.data[ev*3+2] = penv->VolPoints[ev] >> 8;
-				iti.panenv.data[ev*3] = penv->PanEnv[ev] - 32;
-				iti.panenv.data[ev*3+1] = penv->PanPoints[ev] & 0xFF;
-				iti.panenv.data[ev*3+2] = penv->PanPoints[ev] >> 8;
-				iti.pitchenv.data[ev*3] = penv->PitchEnv[ev] - 32;
-				iti.pitchenv.data[ev*3+1] = penv->PitchPoints[ev] & 0xFF;
-				iti.pitchenv.data[ev*3+2] = penv->PitchPoints[ev] >> 8;
-			}
-		} else
-		// Save Empty Instrument
-		{
-			for (UINT i=0; i<NOTE_MAX; i++) iti.keyboard[i*2] = i;
-			iti.ppc = 5*12;
-			iti.gbv = 128;
-			iti.dfp = 0x20;
-			iti.ifc = 0xFF;
-		}
-		if (!iti.nos) iti.trkvers = 0;
-		// Writing instrument
-		inspos[nins-1] = dwPos;
-		dwPos += sizeof(ITINSTRUMENT);
-
-		memcpy(&writeiti, &iti, sizeof(ITINSTRUMENT));
-
-		writeiti.fadeout = bswapLE16(writeiti.fadeout);
-		writeiti.id = bswapLE32(writeiti.id);
-		writeiti.trkvers = bswapLE16(writeiti.trkvers);
-		writeiti.mbank = bswapLE16(writeiti.mbank);
-
-		fwrite(&writeiti, 1, sizeof(ITINSTRUMENT), f);
-	}
-	// Writing sample headers
-	memset(&itss, 0, sizeof(itss));
-	for (UINT hsmp=0; hsmp<header.smpnum; hsmp++)
-	{
-		smppos[hsmp] = dwPos;
-		dwPos += sizeof(ITSAMPLESTRUCT);
-		fwrite(&itss, 1, sizeof(ITSAMPLESTRUCT), f);
-	}
-	// Writing Patterns
-	for (UINT npat=0; npat<header.patnum; npat++)
-	{
-		DWORD dwPatPos = dwPos;
-		UINT len;
-		if (!Patterns[npat]) continue;
-		patpos[npat] = dwPos;
-		patinfo[0] = 0;
-		patinfo[1] = bswapLE16(PatternSize[npat]);
-		patinfo[2] = 0;
-		patinfo[3] = 0;
-		// Check for empty pattern
-		if (PatternSize[npat] == 64)
-		{
-			MODCOMMAND *pzc = Patterns[npat];
-			UINT iz, nz = PatternSize[npat] * m_nChannels;
-			for (iz=0; iz<nz; iz++)
-			{
-				if ((pzc[iz].note) || (pzc[iz].instr)
-				 || (pzc[iz].volcmd) || (pzc[iz].command)) break;
-			}
-			if (iz == nz)
-			{
-				patpos[npat] = 0;
-				continue;
-			}
-		}
-		fwrite(patinfo, 8, 1, f);
-		dwPos += 8;
-		memset(chnmask, 0xFF, sizeof(chnmask));
-		memset(lastvalue, 0, sizeof(lastvalue));
-		MODCOMMAND *m = Patterns[npat];
-		for (UINT row=0; row<PatternSize[npat]; row++)
-		{
-			len = 0;
-			for (UINT ch=0; ch<m_nChannels; ch++, m++)
-			{
-				BYTE b = 0;
-				UINT command = m->command;
-				UINT param = m->param;
-				UINT vol = 0xFF;
-				UINT note = m->note;
-				if (note) b |= 1;
-				if ((note) && (note < 0x80)) note--; // 0xfe->0x80 --Toad
-				if (m->instr) b |= 2;
-				if (m->volcmd)
-				{
-					UINT volcmd = m->volcmd;
-					switch(volcmd)
-					{
-					case VOLCMD_VOLUME:			vol = m->vol; if (vol > 64) vol = 64; break;
-					case VOLCMD_PANNING:		vol = m->vol + 128; if (vol > 192) vol = 192; break;
-					case VOLCMD_VOLSLIDEUP:		vol = 85 + ConvertVolParam(m->vol); break;
-					case VOLCMD_VOLSLIDEDOWN:	vol = 95 + ConvertVolParam(m->vol); break;
-					case VOLCMD_FINEVOLUP:		vol = 65 + ConvertVolParam(m->vol); break;
-					case VOLCMD_FINEVOLDOWN:	vol = 75 + ConvertVolParam(m->vol); break;
-					case VOLCMD_VIBRATOSPEED:	vol = 203 + ConvertVolParam(m->vol); break;
-					case VOLCMD_VIBRATO:		vol = 203; break;
-					case VOLCMD_TONEPORTAMENTO:	vol = 193 + ConvertVolParam(m->vol); break;
-					case VOLCMD_PORTADOWN:		vol = 105 + ConvertVolParam(m->vol); break;
-					case VOLCMD_PORTAUP:		vol = 115 + ConvertVolParam(m->vol); break;
-					default:					vol = 0xFF;
-					}
-				}
-				if (vol != 0xFF) b |= 4;
-				if (command)
-				{
-					S3MSaveConvert(&command, &param, TRUE);
-					if (command) b |= 8;
-				}
-				// Packing information
-				if (b)
-				{
-					// Same note ?
-					if (b & 1)
-					{
-						if ((note == lastvalue[ch].note) && (lastvalue[ch].volcmd & 1))
-						{
-							b &= ~1;
-							b |= 0x10;
-						} else
-						{
-							lastvalue[ch].note = note;
-							lastvalue[ch].volcmd |= 1;
-						}
-					}
-					// Same instrument ?
-					if (b & 2)
-					{
-						if ((m->instr == lastvalue[ch].instr) && (lastvalue[ch].volcmd & 2))
-						{
-							b &= ~2;
-							b |= 0x20;
-						} else
-						{
-							lastvalue[ch].instr = m->instr;
-							lastvalue[ch].volcmd |= 2;
-						}
-					}
-					// Same volume column byte ?
-					if (b & 4)
-					{
-						if ((vol == lastvalue[ch].vol) && (lastvalue[ch].volcmd & 4))
-						{
-							b &= ~4;
-							b |= 0x40;
-						} else
-						{
-							lastvalue[ch].vol = vol;
-							lastvalue[ch].volcmd |= 4;
-						}
-					}
-					// Same command / param ?
-					if (b & 8)
-					{
-						if ((command == lastvalue[ch].command) && (param == lastvalue[ch].param) && (lastvalue[ch].volcmd & 8))
-						{
-							b &= ~8;
-							b |= 0x80;
-						} else
-						{
-							lastvalue[ch].command = command;
-							lastvalue[ch].param = param;
-							lastvalue[ch].volcmd |= 8;
-						}
-					}
-					if (b != chnmask[ch])
-					{
-						chnmask[ch] = b;
-						buf[len++] = (ch+1) | 0x80;
-						buf[len++] = b;
-					} else
-					{
-						buf[len++] = ch+1;
-					}
-					if (b & 1) buf[len++] = note;
-					if (b & 2) buf[len++] = m->instr;
-					if (b & 4) buf[len++] = vol;
-					if (b & 8)
-					{
-						buf[len++] = command;
-						buf[len++] = param;
-					}
-				}
-			}
-			buf[len++] = 0;
-			dwPos += len;
-			patinfo[0] += len;
-			fwrite(buf, 1, len, f);
-		}
-		fseek(f, dwPatPos, SEEK_SET);
-		patinfo[0] = bswapLE16(patinfo[0]); // byteswap -- Toad
-		fwrite(patinfo, 8, 1, f);
-		fseek(f, dwPos, SEEK_SET);
-	}
-	// Writing Sample Data
-	for (UINT nsmp=1; nsmp<=header.smpnum; nsmp++)
-	{
-		MODINSTRUMENT *psmp = &Ins[nsmp];
-		memset(&itss, 0, sizeof(itss));
-		memcpy(itss.filename, psmp->name, 12);
-		memcpy(itss.name, m_szNames[nsmp], 26);
-		itss.id = 0x53504D49;
-		itss.gvl = (BYTE)psmp->nGlobalVol;
-		if (m_nInstruments)
-		{
-			for (UINT iu=1; iu<=m_nInstruments; iu++) if (Headers[iu])
-			{
-				INSTRUMENTHEADER *penv = Headers[iu];
-				for (UINT ju=0; ju<128; ju++) if (penv->Keyboard[ju] == nsmp)
-				{
-					itss.flags = 0x01;
-					break;
-				}
-			}
-		} else
-		{
-			itss.flags = 0x01;
-		}
-		if (psmp->uFlags & CHN_LOOP) itss.flags |= 0x10;
-		if (psmp->uFlags & CHN_SUSTAINLOOP) itss.flags |= 0x20;
-		if (psmp->uFlags & CHN_PINGPONGLOOP) itss.flags |= 0x40;
-		if (psmp->uFlags & CHN_PINGPONGSUSTAIN) itss.flags |= 0x80;
-		itss.C5Speed = psmp->nC4Speed;
-		if (!itss.C5Speed) // if no C5Speed assume it is XM Sample
-		{
-			UINT period;
-
-			/**
-			 * C5 note => number 61, but in XM samples:
-			 * RealNote = Note + RelativeTone
-			 */
-			period = GetPeriodFromNote(61+psmp->RelativeTone, psmp->nFineTune, 0);
-
-			if (period)
-				itss.C5Speed = GetFreqFromPeriod(period, 0, 0);
-			/**
-			 * If it didn`t work, it may not be a XM file;
-			 * so put the default C5Speed, 8363Hz.
-			 */
-	 		if (!itss.C5Speed) itss.C5Speed = 8363;
-		}
-
-		itss.length = psmp->nLength;
-		itss.loopbegin = psmp->nLoopStart;
-		itss.loopend = psmp->nLoopEnd;
-		itss.susloopbegin = psmp->nSustainStart;
-		itss.susloopend = psmp->nSustainEnd;
-		itss.vol = psmp->nVolume >> 2;
-		itss.dfp = psmp->nPan >> 2;
-		itss.vit = autovibxm2it[psmp->nVibType & 7];
-		itss.vis = psmp->nVibRate;
-		itss.vid = psmp->nVibDepth;
-		itss.vir = (psmp->nVibSweep < 64) ? psmp->nVibSweep * 4 : 255;
-		if (psmp->uFlags & CHN_PANNING) itss.dfp |= 0x80;
-		if ((psmp->pSample) && (psmp->nLength)) itss.cvt = 0x01;
-		UINT flags = RS_PCM8S;
-#ifndef NO_PACKING
-		if (nPacking)
-		{
-			if ((!(psmp->uFlags & (CHN_16BIT|CHN_STEREO)))
-			 && (CanPackSample((char *)psmp->pSample, psmp->nLength, nPacking)))
-			{
-				flags = RS_ADPCM4;
-				itss.cvt = 0xFF;
-			}
-		} else
-#endif // NO_PACKING
-		{
-			if (psmp->uFlags & CHN_STEREO)
-			{
-				flags = RS_STPCM8S;
-				itss.flags |= 0x04;
-			}
-			if (psmp->uFlags & CHN_16BIT)
-			{
-				itss.flags |= 0x02;
-				flags = (psmp->uFlags & CHN_STEREO) ? RS_STPCM16S : RS_PCM16S;
-			}
-		}
-		itss.samplepointer = dwPos;
-		fseek(f, smppos[nsmp-1], SEEK_SET);
-
-		itss.id = bswapLE32(itss.id);
-		itss.length = bswapLE32(itss.length);
-		itss.loopbegin = bswapLE32(itss.loopbegin);
-		itss.loopend = bswapLE32(itss.loopend);
-		itss.C5Speed = bswapLE32(itss.C5Speed);
-		itss.susloopbegin = bswapLE32(itss.susloopbegin);
-		itss.susloopend = bswapLE32(itss.susloopend);
-		itss.samplepointer = bswapLE32(itss.samplepointer);
-
-		fwrite(&itss, 1, sizeof(ITSAMPLESTRUCT), f);
-		fseek(f, dwPos, SEEK_SET);
-		if ((psmp->pSample) && (psmp->nLength))
-		{
-			dwPos += WriteSample(f, psmp, flags);
-		}
-	}
-	// Updating offsets
-	fseek(f, dwHdrPos, SEEK_SET);
-
-	/* <Toad> Now we can byteswap them ;-) */
-	UINT WW;
-	UINT WX;
-	WX = (UINT)header.insnum;
-	WX <<= 2;
-	for (WW=0; WW < (WX>>2); WW++)
-	       inspos[WW] = bswapLE32(inspos[WW]);
-
-	WX = (UINT)header.smpnum;
-	WX <<= 2;
-	for (WW=0; WW < (WX>>2); WW++)
-	       smppos[WW] = bswapLE32(smppos[WW]);
-
-	WX=(UINT)header.patnum;
-	WX <<= 2;
-	for (WW=0; WW < (WX>>2); WW++)
-	       patpos[WW] = bswapLE32(patpos[WW]);
-
-	if (header.insnum) fwrite(inspos, 4, header.insnum, f);
-	if (header.smpnum) fwrite(smppos, 4, header.smpnum, f);
-	if (header.patnum) fwrite(patpos, 4, header.patnum, f);
-	fclose(f);
-	return TRUE;
-}
-
-#ifdef _MSC_VER
-//#pragma warning(default:4100)
-#endif
-#endif // MODPLUG_NO_FILESAVE
-
 //////////////////////////////////////////////////////////////////////////////
 // IT 2.14 compression
 
diff --git a/src/load_j2b.cpp b/src/load_j2b.cpp
deleted file mode 100644
index 2d86ce8..0000000
--- a/src/load_j2b.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-/*
- * This source code is public domain.
- *
- * Authors: Olivier Lapicque <olivierl@jps.net>
-*/
-
-
-///////////////////////////////////////////////////
-//
-// J2B module loader
-//
-///////////////////////////////////////////////////
-#include "stdafx.h"
-#include "sndfile.h"
-
diff --git a/src/load_mdl.cpp b/src/load_mdl.cpp
index 8f2724f..177f322 100644
--- a/src/load_mdl.cpp
+++ b/src/load_mdl.cpp
@@ -42,7 +42,7 @@ typedef struct MDLPATTERNDATA
 } MDLPATTERNDATA;
 
 
-void ConvertMDLCommand(MODCOMMAND *m, UINT eff, UINT data)
+static void ConvertMDLCommand(MODCOMMAND *m, UINT eff, UINT data)
 //--------------------------------------------------------
 {
 	UINT command = 0, param = data;
@@ -91,7 +91,7 @@ void ConvertMDLCommand(MODCOMMAND *m, UINT eff, UINT data)
 }
 
 
-void UnpackMDLTrack(MODCOMMAND *pat, UINT nChannels, UINT nRows, UINT nTrack, const BYTE *lpTracks, UINT len)
+static void UnpackMDLTrack(MODCOMMAND *pat, UINT nChannels, UINT nRows, UINT nTrack, const BYTE *lpTracks, UINT len)
 //-------------------------------------------------------------------------------------------------
 {
 	MODCOMMAND cmd, *m = pat;
@@ -168,7 +168,6 @@ void UnpackMDLTrack(MODCOMMAND *pat, UINT nChannels, UINT nRows, UINT nTrack, co
 }
 
 
-
 BOOL CSoundFile::ReadMDL(const BYTE *lpStream, DWORD dwMemLength)
 //---------------------------------------------------------------
 {
diff --git a/src/load_med.cpp b/src/load_med.cpp
index 745e2c6..614674e 100644
--- a/src/load_med.cpp
+++ b/src/load_med.cpp
@@ -876,7 +876,7 @@ BOOL CSoundFile::ReadMed(const BYTE *lpStream, DWORD dwMemLength)
 				{
 					DWORD nameofs = bswapBE32(pbi->blockname);
 					UINT namelen = bswapBE32(pbi->blocknamelen);
-					if ((nameofs < dwMemLength) && (namelen < dwMemLength + nameofs))
+					if ((nameofs < dwMemLength) && (namelen < dwMemLength - nameofs))
 					{
 						SetPatternName(iBlk, (LPCSTR)(lpStream+nameofs));
 					}
diff --git a/src/load_mid.cpp b/src/load_mid.cpp
index 5992fa6..734a247 100644
--- a/src/load_mid.cpp
+++ b/src/load_mid.cpp
@@ -30,11 +30,22 @@
 #include <math.h>
 #include <ctype.h>
 #ifndef _WIN32
-#include <unistd.h> // for sleep
+#include <unistd.h> /* sleep() */
 #endif
 
 #include "stdafx.h"
 #include "sndfile.h"
+
+#ifndef MIDIFMT_SUPPORT
+BOOL CSoundFile::TestMID(const BYTE *lpStream, DWORD dwMemLength) {
+	return FALSE;
+}
+BOOL CSoundFile::ReadMID(const BYTE *lpStream, DWORD dwMemLength) {
+	return FALSE;
+}
+
+#else
+
 #define PAN_LEFT    0x30
 #define PAN_RIGHT   0xD0
 #define MAX_POLYPHONY 16  // max notes in one midi channel
@@ -88,11 +99,11 @@ typedef struct _MIDTRACK
 	BYTE instr;	// current instrument for this track
 } MIDTRACK;
 
-#if defined(WIN32) && defined(_mm_free)
+#if defined(_WIN32) && defined(_mm_free)
 #undef _mm_free
 #endif
 
-#define MMSTREAM										FILE
+#define MMSTREAM				FILE
 #define _mm_fseek(f,pos,whence)			fseek(f,pos,whence)
 #define _mm_read_UBYTES(buf,sz,f)		fread(buf,sz,1,f)
 #define _mm_read_SBYTES(buf,sz,f)		fread(buf,sz,1,f)
@@ -256,18 +267,18 @@ static void mid_adjust_for_optimal_tempo(MIDHANDLE *h, int maxtempo)
 static MIDEVENT *mid_new_event(MIDHANDLE *h)
 // =====================================================================================
 {
-    MIDEVENT   *retval;
-
-    retval = (MIDEVENT *)_mm_calloc(h->trackhandle, 1,sizeof(MIDEVENT));
-		retval->next      = NULL;
-    retval->tracktick = h->tracktime;
-		retval->flg       = 0;
-		retval->note      = 0;
-		retval->volume    = 0;
-		retval->smpno     = 0;
-		retval->fx        = none;
-		retval->fxparam   = 0;
-    return retval;
+	MIDEVENT   *retval;
+
+	retval = (MIDEVENT *)_mm_calloc(h->trackhandle, 1,sizeof(MIDEVENT));
+	retval->next      = NULL;
+	retval->tracktick = h->tracktime;
+	retval->flg       = 0;
+	retval->note      = 0;
+	retval->volume    = 0;
+	retval->smpno     = 0;
+	retval->fx        = none;
+	retval->fxparam   = 0;
+	return retval;
 }
 
 // =====================================================================================
@@ -1582,3 +1593,4 @@ BOOL CSoundFile::ReadMID(const BYTE *lpStream, DWORD dwMemLength)
 	avoid_reentry = 0; // it is safe now, I'm finished
 	return TRUE;
 }
+#endif // MIDIFMT_SUPPORT
diff --git a/src/load_mod.cpp b/src/load_mod.cpp
index c8ba8d2..68ee30b 100644
--- a/src/load_mod.cpp
+++ b/src/load_mod.cpp
@@ -39,7 +39,9 @@ void CSoundFile::ConvertModCommand(MODCOMMAND *m) const
 	case 0x0D:	command = CMD_PATTERNBREAK; param = ((param >> 4) * 10) + (param & 0x0F); break;
 	case 0x0E:	command = CMD_MODCMDEX; break;
 	case 0x0F:	command = (param <= (UINT)((m_nType & (MOD_TYPE_XM|MOD_TYPE_MT2)) ? 0x1F : 0x20)) ? CMD_SPEED : CMD_TEMPO;
-				if ((param == 0xFF) && (m_nSamples == 15)) command = 0; break;
+			if((param == 0xFF) && (m_nSamples == 15))
+			    command = 0;
+			break;
 	// Extension for XM extended effects
 	case 'G' - 55:	command = CMD_GLOBALVOLUME; break;
 	case 'H' - 55:	command = CMD_GLOBALVOLSLIDE; if (param & 0xF0) param &= 0xF0; break;
@@ -59,95 +61,7 @@ void CSoundFile::ConvertModCommand(MODCOMMAND *m) const
 	m->param = param;
 }
 
-
-WORD CSoundFile::ModSaveCommand(const MODCOMMAND *m, BOOL bXM) const
-//------------------------------------------------------------------
-{
-	UINT command = m->command & 0x3F, param = m->param;
-
-	switch(command)
-	{
-	case 0:						command = param = 0; break;
-	case CMD_ARPEGGIO:			command = 0; break;
-	case CMD_PORTAMENTOUP:
-		if (m_nType & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_STM))
-		{
-			if ((param & 0xF0) == 0xE0) { command=0x0E; param=((param & 0x0F) >> 2)|0x10; break; }
-			else if ((param & 0xF0) == 0xF0) { command=0x0E; param &= 0x0F; param|=0x10; break; }
-		}
-		command = 0x01;
-		break;
-	case CMD_PORTAMENTODOWN:
-		if (m_nType & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_STM))
-		{
-			if ((param & 0xF0) == 0xE0) { command=0x0E; param=((param & 0x0F) >> 2)|0x20; break; }
-			else if ((param & 0xF0) == 0xF0) { command=0x0E; param &= 0x0F; param|=0x20; break; }
-		}
-		command = 0x02;
-		break;
-	case CMD_TONEPORTAMENTO:	command = 0x03; break;
-	case CMD_VIBRATO:			command = 0x04; break;
-	case CMD_TONEPORTAVOL:		command = 0x05; break;
-	case CMD_VIBRATOVOL:		command = 0x06; break;
-	case CMD_TREMOLO:			command = 0x07; break;
-	case CMD_PANNING8:			
-		command = 0x08;
-		if (bXM)
-		{
-			if ((m_nType != MOD_TYPE_IT) && (m_nType != MOD_TYPE_XM) && (param <= 0x80))
-			{
-				param <<= 1;
-				if (param > 255) param = 255;
-			}
-		} else
-		{
-			if ((m_nType == MOD_TYPE_IT) || (m_nType == MOD_TYPE_XM)) param >>= 1;
-		}
-		break;
-	case CMD_OFFSET:			command = 0x09; break;
-	case CMD_VOLUMESLIDE:		command = 0x0A; break;
-	case CMD_POSITIONJUMP:		command = 0x0B; break;
-	case CMD_VOLUME:			command = 0x0C; break;
-	case CMD_PATTERNBREAK:		command = 0x0D; param = ((param / 10) << 4) | (param % 10); break;
-	case CMD_MODCMDEX:			command = 0x0E; break;
-	case CMD_SPEED:				command = 0x0F; if (param > 0x20) param = 0x20; break;
-	case CMD_TEMPO:				if (param > 0x20) { command = 0x0F; break; }
-	case CMD_GLOBALVOLUME:		command = 'G' - 55; break;
-	case CMD_GLOBALVOLSLIDE:	command = 'H' - 55; break;
-	case CMD_KEYOFF:			command = 'K' - 55; break;
-	case CMD_SETENVPOSITION:	command = 'L' - 55; break;
-	case CMD_CHANNELVOLUME:		command = 'M' - 55; break;
-	case CMD_CHANNELVOLSLIDE:	command = 'N' - 55; break;
-	case CMD_PANNINGSLIDE:		command = 'P' - 55; break;
-	case CMD_RETRIG:			command = 'R' - 55; break;
-	case CMD_TREMOR:			command = 'T' - 55; break;
-	case CMD_XFINEPORTAUPDOWN:	command = 'X' - 55; break;
-	case CMD_PANBRELLO:			command = 'Y' - 55; break;
-	case CMD_MIDI:				command = 'Z' - 55; break;
-	case CMD_S3MCMDEX:
-		switch(param & 0xF0)
-		{
-		case 0x10:	command = 0x0E; param = (param & 0x0F) | 0x30; break;
-		case 0x20:	command = 0x0E; param = (param & 0x0F) | 0x50; break;
-		case 0x30:	command = 0x0E; param = (param & 0x0F) | 0x40; break;
-		case 0x40:	command = 0x0E; param = (param & 0x0F) | 0x70; break;
-		case 0x90:	command = 'X' - 55; break;
-		case 0xB0:	command = 0x0E; param = (param & 0x0F) | 0x60; break;
-		case 0xA0:
-		case 0x50:
-		case 0x70:
-		case 0x60:	command = param = 0; break;
-		default:	command = 0x0E; break;
-		}
-		break;
-	default:		command = param = 0;
-	}
-	return (WORD)((command << 8) | (param));
-}
-
-
 #pragma pack(1)
-
 typedef struct _MODSAMPLE
 {
 	CHAR name[22];
@@ -165,7 +79,6 @@ typedef struct _MODMAGIC
 	BYTE Orders[128];
         char Magic[4];          // changed from CHAR
 } MODMAGIC, *PMODMAGIC;
-
 #pragma pack()
 
 static BOOL IsValidName(LPCSTR s, int length, CHAR minChar)
@@ -184,12 +97,11 @@ static BOOL IsValidName(LPCSTR s, int length, CHAR minChar)
 	return TRUE;
 }
 
-BOOL IsMagic(LPCSTR s1, LPCSTR s2)
+static BOOL IsMagic(LPCSTR s1, LPCSTR s2)
 {
 	return ((*(DWORD *)s1) == (*(DWORD *)s2)) ? TRUE : FALSE;
 }
 
-
 BOOL CSoundFile::ReadMod(const BYTE *lpStream, DWORD dwMemLength)
 //---------------------------------------------------------------
 {
@@ -386,151 +298,5 @@ BOOL CSoundFile::ReadMod(const BYTE *lpStream, DWORD dwMemLength)
 			dwErrCheck++;
 		}
 	}
-#ifdef MODPLUG_TRACKER
-	return TRUE;
-#else
 	return (dwErrCheck) ? TRUE : FALSE;
-#endif
-}
-
-
-#ifndef MODPLUG_NO_FILESAVE
-
-#ifdef _MSC_VER
-#pragma warning(disable:4100)
-#endif
-
-BOOL CSoundFile::SaveMod(LPCSTR lpszFileName, UINT nPacking)
-//----------------------------------------------------------
-{
-	BYTE insmap[32];
-	UINT inslen[32];
-	BYTE bTab[32];
-	BYTE ord[128];
-	FILE *f;
-
-	if ((!m_nChannels) || (!lpszFileName)) return FALSE;
-	if ((f = fopen(lpszFileName, "wb")) == NULL) return FALSE;
-	memset(ord, 0, sizeof(ord));
-	memset(inslen, 0, sizeof(inslen));
-	if (m_nInstruments)
-	{
-		memset(insmap, 0, sizeof(insmap));
-		for (UINT i=1; i<32; i++) if (Headers[i])
-		{
-			for (UINT j=0; j<128; j++) if (Headers[i]->Keyboard[j])
-			{
-				insmap[i] = Headers[i]->Keyboard[j];
-				break;
-			}
-		}
-	} else
-	{
-		for (UINT i=0; i<32; i++) insmap[i] = (BYTE)i;
-	}
-	// Writing song name
-	fwrite(m_szNames, 20, 1, f);
-	// Writing instrument definition
-	for (UINT iins=1; iins<=31; iins++)
-	{
-		MODINSTRUMENT *pins = &Ins[insmap[iins]];
-		memcpy(bTab, m_szNames[iins],22);
-		inslen[iins] = pins->nLength;
-		if (inslen[iins] > 0x1fff0) inslen[iins] = 0x1fff0;
-		bTab[22] = inslen[iins] >> 9;
-		bTab[23] = inslen[iins] >> 1;
-		if (pins->RelativeTone < 0) bTab[24] = 0x08; else
-		if (pins->RelativeTone > 0) bTab[24] = 0x07; else
-		bTab[24] = (BYTE)XM2MODFineTune(pins->nFineTune);
-		bTab[25] = pins->nVolume >> 2;
-		bTab[26] = pins->nLoopStart >> 9;
-		bTab[27] = pins->nLoopStart >> 1;
-		bTab[28] = (pins->nLoopEnd - pins->nLoopStart) >> 9;
-		bTab[29] = (pins->nLoopEnd - pins->nLoopStart) >> 1;
-		fwrite(bTab, 30, 1, f);
-	}
-	// Writing number of patterns
-	UINT nbp=0, norders=128;
-	for (UINT iord=0; iord<128; iord++)
-	{
-		if (Order[iord] == 0xFF)
-		{
-			norders = iord;
-			break;
-		}
-		if ((Order[iord] < 0x80) && (nbp<=Order[iord])) nbp = Order[iord]+1;
-	}
-	bTab[0] = norders;
-	bTab[1] = m_nRestartPos;
-	fwrite(bTab, 2, 1, f);
-	// Writing pattern list
-	if (norders) memcpy(ord, Order, norders);
-	fwrite(ord, 128, 1, f);
-	// Writing signature
-	if (m_nChannels == 4)
-		lstrcpy((LPSTR)&bTab, "M.K.");
-	else
-		wsprintf((LPSTR)&bTab, "%luCHN", m_nChannels);
-	fwrite(bTab, 4, 1, f);
-	// Writing patterns
-	for (UINT ipat=0; ipat<nbp; ipat++) if (Patterns[ipat])
-	{
-		BYTE s[64*4];
-		MODCOMMAND *m = Patterns[ipat];
-		for (UINT i=0; i<64; i++) if (i < PatternSize[ipat])
-		{
-			LPBYTE p=s;
-			for (UINT c=0; c<m_nChannels; c++,p+=4,m++)
-			{
-				UINT param = ModSaveCommand(m, FALSE);
-				UINT command = param >> 8;
-				param &= 0xFF;
-				if (command > 0x0F) command = param = 0;
-				if ((m->vol >= 0x10) && (m->vol <= 0x50) && (!command) && (!param)) { command = 0x0C; param = m->vol - 0x10; }
-				UINT period = m->note;
-				if (period)
-				{
-					if (period < 37) period = 37;
-					period -= 37;
-					if (period >= 6*12) period = 6*12-1;
-					period = ProTrackerPeriodTable[period];
-				}
-				UINT instr = (m->instr > 31) ? 0 : m->instr;
-				p[0] = ((period >> 8) & 0x0F) | (instr & 0x10);
-				p[1] = period & 0xFF;
-				p[2] = ((instr & 0x0F) << 4) | (command & 0x0F);
-				p[3] = param;
-			}
-			fwrite(s, m_nChannels, 4, f);
-		} else
-		{
-			memset(s, 0, m_nChannels*4);
-			fwrite(s, m_nChannels, 4, f);
-		}
-	}
-	// Writing instruments
-	for (UINT ismpd=1; ismpd<=31; ismpd++) if (inslen[ismpd])
-	{
-		MODINSTRUMENT *pins = &Ins[insmap[ismpd]];
-		UINT flags = RS_PCM8S;
-#ifndef NO_PACKING
-		if (!(pins->uFlags & (CHN_16BIT|CHN_STEREO)))
-		{
-			if ((nPacking) && (CanPackSample((char *)pins->pSample, inslen[ismpd], nPacking)))
-			{
-				fwrite("ADPCM", 1, 5, f);
-				flags = RS_ADPCM4;
-			}
-		}
-#endif
-		WriteSample(f, pins, flags, inslen[ismpd]);
-	}
-	fclose(f);
-	return TRUE;
 }
-
-#ifdef _MSC_VER
-#pragma warning(default:4100)
-#endif
-
-#endif // MODPLUG_NO_FILESAVE
diff --git a/src/load_pat.cpp b/src/load_pat.cpp
index adcccc3..9546272 100644
--- a/src/load_pat.cpp
+++ b/src/load_pat.cpp
@@ -33,36 +33,47 @@
 #include <string.h>
 #include <math.h>
 #include <ctype.h>
+#include <limits.h> /* PATH_MAX */
 #ifndef _WIN32
-#include <limits.h> // for PATH_MAX
-#include <unistd.h> // for sleep
+#include <unistd.h>  /* sleep() */
 #endif
+
+#include "stdafx.h"
+#include "sndfile.h"
 #ifndef PATH_MAX
 #define PATH_MAX 256
 #endif
 
-#include "stdafx.h"
-#include "sndfile.h"
+#ifndef MIDIFMT_SUPPORT
+BOOL CSoundFile::TestPAT(const BYTE *lpStream, DWORD dwMemLength) {
+	return FALSE;
+}
+BOOL CSoundFile::ReadPAT(const BYTE *lpStream, DWORD dwMemLength) {
+	return FALSE;
+}
+
+#else
 
 #include "load_pat.h"
 
-#ifdef MSC_VER
+#if defined(_WIN32)||defined(__OS2__)
 #define DIRDELIM		'\\'
 #define TIMIDITYCFG	"C:\\TIMIDITY\\TIMIDITY.CFG"
 #define PATHFORPAT	"C:\\TIMIDITY\\INSTRUMENTS"
 #else
 #define DIRDELIM		'/'
-#define TIMIDITYCFG	"/usr/local/share/timidity/timidity.cfg"
-#define PATHFORPAT	"/usr/local/share/timidity/instruments"
+#define TIMIDITYCFG	"/etc/timidity.cfg" /*"/usr/share/timidity/timidity.cfg"*/
+#define PATHFORPAT	"/usr/share/timidity/instruments"
 #endif
 
 #define PAT_ENV_PATH2CFG			"MMPAT_PATH_TO_CFG"
 
 // 128 gm and 63 drum
 #define MAXSMP				191
+
 static char midipat[MAXSMP][PATH_MAX];
-static char pathforpat[PATH_MAX] = {};
-static char timiditycfg[PATH_MAX] = {};
+static char pathforpat[PATH_MAX];
+static char timiditycfg[PATH_MAX];
 
 #pragma pack(1)
 
@@ -272,7 +283,7 @@ typedef float (*PAT_SAMPLE_FUN)(int);
 
 static PAT_SAMPLE_FUN pat_fun[] = { pat_sinus, pat_square, pat_sawtooth };
 
-#if defined(WIN32) && defined(_mm_free)
+#if defined(_WIN32) && defined(_mm_free)
 #undef _mm_free
 #endif
 
@@ -764,10 +775,7 @@ BOOL CSoundFile::TestPAT(const BYTE *lpStream, DWORD dwMemLength)
 // =====================================================================================
 static PATHANDLE *PAT_Init(void)
 {
-	PATHANDLE   *retval;
-	retval = (PATHANDLE *)calloc(1,sizeof(PATHANDLE));
-	if( !retval ) return NULL;
-	return retval;
+	return (PATHANDLE *)calloc(1,sizeof(PATHANDLE));
 }
 
 // =====================================================================================
@@ -1259,3 +1267,4 @@ BOOL CSoundFile::ReadPAT(const BYTE *lpStream, DWORD dwMemLength)
 	PAT_Cleanup(h);	// we dont need it anymore
 	return 1;
 }
+#endif // MIDIFMT_SUPPORT
diff --git a/src/load_psm.cpp b/src/load_psm.cpp
index 92c5bf9..d107375 100644
--- a/src/load_psm.cpp
+++ b/src/load_psm.cpp
@@ -84,7 +84,9 @@ typedef struct _PSMSAMPLE
 	BYTE reserved6[19];
 } PSMSAMPLE;
 
-void swap_PSMSAMPLE(PSMSAMPLE* p){
+#pragma pack()
+
+static void swap_PSMSAMPLE(PSMSAMPLE* p){
 	p->smpid = bswapLE32(p->smpid);
 	p->length = bswapLE32(p->length);
 	p->loopstart = bswapLE32(p->loopstart);
@@ -92,8 +94,6 @@ void swap_PSMSAMPLE(PSMSAMPLE* p){
 	p->samplerate = bswapLE32(p->samplerate);
 }
 
-#pragma pack()
-
 
 BOOL CSoundFile::ReadPSM(LPCBYTE lpStream, DWORD dwMemLength)
 //-----------------------------------------------------------
@@ -313,17 +313,17 @@ BOOL CSoundFile::ReadPSM(LPCBYTE lpStream, DWORD dwMemLength)
 			ch = p[pos++];
 			if (ch >= m_nChannels) {
 				sp = &dummy;
-            } else {
+			} else {
 				sp = &m[ch];
-            }
+			}
 			// Note + Instr
-            if ((flags & 0x80) && (pos+1 < len))
-        	{
-                UINT note = p[pos++];
-                note = (note>>4)*12+(note&0x0f)+12+1;
-                if (note > 0x80) note = 0;
+			if ((flags & 0x80) && (pos+1 < len))
+			{
+				UINT note = p[pos++];
+				note = (note>>4)*12+(note&0x0f)+12+1;
+				if (note > 0x80) note = 0;
 				sp->note = note;
-            }
+			}
 			if ((flags & 0x40) && (pos+1 < len))
 			{
 				UINT nins = p[pos++];
@@ -351,10 +351,10 @@ BOOL CSoundFile::ReadPSM(LPCBYTE lpStream, DWORD dwMemLength)
 				case 0x01:	command = CMD_VOLUMESLIDE; param |= 0x0f;
 						if (param == 15) param=31;
 						break;
-                                // 02: volslide up
-                                case 0x02:      command = CMD_VOLUMESLIDE; param>>=1; param<<=4; break;
-                                // 03: fine volslide down
-                                case 0x03:	command = CMD_VOLUMESLIDE; param>>=4; param |= 0xf0;
+				// 02: volslide up
+				case 0x02:	command = CMD_VOLUMESLIDE; param>>=1; param<<=4; break;
+				// 03: fine volslide down
+				case 0x03:	command = CMD_VOLUMESLIDE; param>>=4; param |= 0xf0;
 						if (param == 240) param=241;
 						break;
 				// 04: fine volslide down
@@ -366,7 +366,7 @@ BOOL CSoundFile::ReadPSM(LPCBYTE lpStream, DWORD dwMemLength)
 				// 0F: tone portamento
 				case 0x0F:	command = CMD_TONEPORTAMENTO; param = param/4; break;
 				// 15: vibrato
-                                case 0x15:	command = CMD_VIBRATO; break;
+				case 0x15:	command = CMD_VIBRATO; break;
 				// 29: sample offset
 				case 0x29:	pos += 2; break;
 				// 2A: retrigger note
@@ -401,466 +401,3 @@ BOOL CSoundFile::ReadPSM(LPCBYTE lpStream, DWORD dwMemLength)
 	// Done (finally!)
 	return TRUE;
 }
-
-
-//////////////////////////////////////////////////////////////
-//
-// PSM Old Format
-//
-
-/*
-
-CONST
-  c_PSM_MaxOrder   = $FF;
-  c_PSM_MaxSample  = $FF;
-  c_PSM_MaxChannel = $0F;
-
- TYPE
-  PPSM_Header = ^TPSM_Header;
-  TPSM_Header = RECORD
-                 PSM_Sign                   : ARRAY[01..04] OF CHAR; { PSM + #254 }
-                 PSM_SongName               : ARRAY[01..58] OF CHAR;
-                 PSM_Byte00                 : BYTE;
-                 PSM_Byte1A                 : BYTE;
-                 PSM_Unknown00              : BYTE;
-                 PSM_Unknown01              : BYTE;
-                 PSM_Unknown02              : BYTE;
-                 PSM_Speed                  : BYTE;
-                 PSM_Tempo                  : BYTE;
-                 PSM_Unknown03              : BYTE;
-                 PSM_Unknown04              : WORD;
-                 PSM_OrderLength            : WORD;
-                 PSM_PatternNumber          : WORD;
-                 PSM_SampleNumber           : WORD;
-                 PSM_ChannelNumber          : WORD;
-                 PSM_ChannelUsed            : WORD;
-                 PSM_OrderPosition          : LONGINT;
-                 PSM_ChannelSettingPosition : LONGINT;
-                 PSM_PatternPosition        : LONGINT;
-                 PSM_SamplePosition         : LONGINT;
-                { *** perhaps there are some more infos in a larger header,
-                      but i have not decoded it and so it apears here NOT }
-                END;
-
-  PPSM_Sample = ^TPSM_Sample;
-  TPSM_Sample = RECORD
-                 PSM_SampleFileName  : ARRAY[01..12] OF CHAR;
-                 PSM_SampleByte00    : BYTE;
-                 PSM_SampleName      : ARRAY[01..22] OF CHAR;
-                 PSM_SampleUnknown00 : ARRAY[01..02] OF BYTE;
-                 PSM_SamplePosition  : LONGINT;
-                 PSM_SampleUnknown01 : ARRAY[01..04] OF BYTE;
-                 PSM_SampleNumber    : BYTE;
-                 PSM_SampleFlags     : WORD;
-                 PSM_SampleLength    : LONGINT;
-                 PSM_SampleLoopBegin : LONGINT;
-                 PSM_SampleLoopEnd   : LONGINT;
-                 PSM_Unknown03       : BYTE;
-                 PSM_SampleVolume    : BYTE;
-                 PSM_SampleC5Speed   : WORD;
-                END;
-
-  PPSM_SampleList = ^TPSM_SampleList;
-  TPSM_SampleList = ARRAY[01..c_PSM_MaxSample] OF TPSM_Sample;
-
-  PPSM_Order = ^TPSM_Order;
-  TPSM_Order = ARRAY[00..c_PSM_MaxOrder] OF BYTE;
-
-  PPSM_ChannelSettings = ^TPSM_ChannelSettings;
-  TPSM_ChannelSettings = ARRAY[00..c_PSM_MaxChannel] OF BYTE;
-
- CONST
-  PSM_NotesInPattern   : BYTE = $00;
-  PSM_ChannelInPattern : BYTE = $00;
-
- CONST
-  c_PSM_SetSpeed = 60;
-
- FUNCTION PSM_Size(FileName : STRING;FilePosition : LONGINT) : LONGINT;
-  BEGIN
-  END;
-
- PROCEDURE PSM_UnpackPattern(VAR Source,Destination;PatternLength : WORD);
-  VAR
-   Witz : ARRAY[00..04] OF WORD;
-   I1,I2        : WORD;
-   I3,I4        : WORD;
-   TopicalByte  : ^BYTE;
-   Pattern      : PUnpackedPattern;
-   ChannelP     : BYTE;
-   NoteP        : BYTE;
-   InfoByte     : BYTE;
-   CodeByte     : BYTE;
-   InfoWord     : WORD;
-   Effect       : BYTE;
-   Opperand     : BYTE;
-   Panning      : BYTE;
-   Volume       : BYTE;
-   PrevInfo     : BYTE;
-   InfoIndex    : BYTE;
-  BEGIN
-   Pattern     := @Destination;
-   TopicalByte := @Source;
-  { *** Initialize patttern }
-   FOR I2 := 0 TO c_Maximum_NoteIndex DO
-    FOR I3 := 0 TO c_Maximum_ChannelIndex DO
-     BEGIN
-      Pattern^[I2,I3,c_Pattern_NoteIndex]     := $FF;
-      Pattern^[I2,I3,c_Pattern_SampleIndex]   := $00;
-      Pattern^[I2,I3,c_Pattern_VolumeIndex]   := $FF;
-      Pattern^[I2,I3,c_Pattern_PanningIndex]  := $FF;
-      Pattern^[I2,I3,c_Pattern_EffectIndex]   := $00;
-      Pattern^[I2,I3,c_Pattern_OpperandIndex] := $00;
-     END;
-  { *** Byte-pointer on first pattern-entry }
-   ChannelP    := $00;
-   NoteP       := $00;
-   InfoByte    := $00;
-   PrevInfo    := $00;
-   InfoIndex   := $02;
-  { *** read notes in pattern }
-   PSM_NotesInPattern   := TopicalByte^; INC(TopicalByte); DEC(PatternLength); INC(InfoIndex);
-   PSM_ChannelInPattern := TopicalByte^; INC(TopicalByte); DEC(PatternLength); INC(InfoIndex);
-  { *** unpack pattern }
-   WHILE (INTEGER(PatternLength) > 0) AND (NoteP < c_Maximum_NoteIndex) DO
-    BEGIN
-    { *** Read info-byte }
-     InfoByte := TopicalByte^; INC(TopicalByte); DEC(PatternLength); INC(InfoIndex);
-     IF InfoByte <> $00 THEN
-      BEGIN
-       ChannelP := InfoByte AND $0F;
-       IF InfoByte AND 128 = 128 THEN { note and sample }
-        BEGIN
-        { *** read note }
-         CodeByte := TopicalByte^; INC(TopicalByte); DEC(PatternLength);
-         DEC(CodeByte);
-         CodeByte := CodeByte MOD 12 * 16 + CodeByte DIV 12 + 2;
-         Pattern^[NoteP,ChannelP,c_Pattern_NoteIndex] := CodeByte;
-        { *** read sample }
-         CodeByte := TopicalByte^; INC(TopicalByte); DEC(PatternLength);
-         Pattern^[NoteP,ChannelP,c_Pattern_SampleIndex] := CodeByte;
-        END;
-       IF InfoByte AND 64 = 64 THEN { Volume }
-        BEGIN
-         CodeByte := TopicalByte^; INC(TopicalByte); DEC(PatternLength);
-         Pattern^[NoteP,ChannelP,c_Pattern_VolumeIndex] := CodeByte;
-        END;
-       IF InfoByte AND 32 = 32 THEN { effect AND opperand }
-        BEGIN
-         Effect   := TopicalByte^; INC(TopicalByte); DEC(PatternLength);
-         Opperand := TopicalByte^; INC(TopicalByte); DEC(PatternLength);
-         CASE Effect OF
-          c_PSM_SetSpeed:
-           BEGIN
-            Effect := c_I_Set_Speed;
-           END;
-          ELSE
-           BEGIN
-            Effect   := c_I_NoEffect;
-            Opperand := $00;
-           END;
-         END;
-         Pattern^[NoteP,ChannelP,c_Pattern_EffectIndex]   := Effect;
-         Pattern^[NoteP,ChannelP,c_Pattern_OpperandIndex] := Opperand;
-        END;
-      END ELSE INC(NoteP);
-    END;
-  END;
-
- PROCEDURE PSM_Load(FileName : STRING;FilePosition : LONGINT;VAR Module : PModule;VAR ErrorCode : WORD);
- { *** caution : Module has to be inited before!!!! }
-  VAR
-   Header             : PPSM_Header;
-   Sample             : PPSM_SampleList;
-   Order              : PPSM_Order;
-   ChannelSettings    : PPSM_ChannelSettings;
-   MultiPurposeBuffer : PByteArray;
-   PatternBuffer      : PUnpackedPattern;
-   TopicalParaPointer : WORD;
-
-   InFile : FILE;
-   I1,I2  : WORD;
-   I3,I4  : WORD;
-   TempW  : WORD;
-   TempB  : BYTE;
-   TempP  : PByteArray;
-   TempI  : INTEGER;
-  { *** copy-vars for loop-extension }
-   CopySource      : LONGINT;
-   CopyDestination : LONGINT;
-   CopyLength      : LONGINT;
-  BEGIN
-  { *** try to open file }
-   ASSIGN(InFile,FileName);
-{$I-}
-   RESET(InFile,1);
-{$I+}
-   IF IORESULT <> $00 THEN
-    BEGIN
-     EXIT;
-    END;
-{$I-}
-  { *** seek start of module }
-   IF FILESIZE(InFile) < FilePosition THEN
-    BEGIN
-     EXIT;
-    END;
-   SEEK(InFile,FilePosition);
-  { *** look for enough memory for temporary variables }
-   IF MEMAVAIL < SIZEOF(TPSM_Header)       + SIZEOF(TPSM_SampleList) +
-                 SIZEOF(TPSM_Order)        + SIZEOF(TPSM_ChannelSettings) +
-                 SIZEOF(TByteArray)        + SIZEOF(TUnpackedPattern)
-   THEN
-    BEGIN
-     EXIT;
-    END;
-  { *** init dynamic variables }
-   NEW(Header);
-   NEW(Sample);
-   NEW(Order);
-   NEW(ChannelSettings);
-   NEW(MultiPurposeBuffer);
-   NEW(PatternBuffer);
-  { *** read header }
-   BLOCKREAD(InFile,Header^,SIZEOF(TPSM_Header));
-  { *** test if this is a DSM-file }
-   IF NOT ((Header^.PSM_Sign[1] = 'P') AND (Header^.PSM_Sign[2] = 'S')   AND
-           (Header^.PSM_Sign[3] = 'M') AND (Header^.PSM_Sign[4] = #254)) THEN
-    BEGIN
-     ErrorCode := c_NoValidFileFormat;
-     CLOSE(InFile);
-     EXIT;
-    END;
-  { *** read order }
-   SEEK(InFile,FilePosition + Header^.PSM_OrderPosition);
-   BLOCKREAD(InFile,Order^,Header^.PSM_OrderLength);
-  { *** read channelsettings }
-   SEEK(InFile,FilePosition + Header^.PSM_ChannelSettingPosition);
-   BLOCKREAD(InFile,ChannelSettings^,SIZEOF(TPSM_ChannelSettings));
-  { *** read samplelist }
-   SEEK(InFile,FilePosition + Header^.PSM_SamplePosition);
-   BLOCKREAD(InFile,Sample^,Header^.PSM_SampleNumber * SIZEOF(TPSM_Sample));
-  { *** copy header to intern NTMIK-structure }
-   Module^.Module_Sign                 := 'MF';
-   Module^.Module_FileFormatVersion    := $0100;
-   Module^.Module_SampleNumber         := Header^.PSM_SampleNumber;
-   Module^.Module_PatternNumber        := Header^.PSM_PatternNumber;
-   Module^.Module_OrderLength          := Header^.PSM_OrderLength;
-   Module^.Module_ChannelNumber        := Header^.PSM_ChannelNumber+1;
-   Module^.Module_Initial_GlobalVolume := 64;
-   Module^.Module_Initial_MasterVolume := $C0;
-   Module^.Module_Initial_Speed        := Header^.PSM_Speed;
-   Module^.Module_Initial_Tempo        := Header^.PSM_Tempo;
-{ *** paragraph 01 start }
-   Module^.Module_Flags                := c_Module_Flags_ZeroVolume        * BYTE(1) +
-                                          c_Module_Flags_Stereo            * BYTE(1) +
-                                          c_Module_Flags_ForceAmigaLimits  * BYTE(0) +
-                                          c_Module_Flags_Panning           * BYTE(1) +
-                                          c_Module_Flags_Surround          * BYTE(1) +
-                                          c_Module_Flags_QualityMixing     * BYTE(1) +
-                                          c_Module_Flags_FastVolumeSlides  * BYTE(0) +
-                                          c_Module_Flags_SpecialCustomData * BYTE(0) +
-                                          c_Module_Flags_SongName          * BYTE(1);
-   I1 := $01;
-   WHILE (Header^.PSM_SongName[I1] > #00) AND (I1 < c_Module_SongNameLength) DO
-    BEGIN
-     Module^.Module_Name[I1] := Header^.PSM_SongName[I1];
-     INC(I1);
-    END;
-   Module^.Module_Name[c_Module_SongNameLength] := #00;
-  { *** Init channelsettings }
-   FOR I1 := 0 TO c_Maximum_ChannelIndex DO
-    BEGIN
-     IF I1 < Header^.PSM_ChannelUsed THEN
-      BEGIN
-      { *** channel enabled }
-       Module^.Module_ChannelSettingPointer^[I1].ChannelSettings_GlobalVolume := 64;
-       Module^.Module_ChannelSettingPointer^[I1].ChannelSettings_Panning      := (ChannelSettings^[I1]) * $08;
-       Module^.Module_ChannelSettingPointer^[I1].ChannelSettings_Code         := I1 + $10 * BYTE(ChannelSettings^[I1] > $08) +
-                                             c_ChannelSettings_Code_ChannelEnabled   * BYTE(1) +
-                                             c_ChannelSettings_Code_ChannelDigital   * BYTE(1);
-       Module^.Module_ChannelSettingPointer^[I1].ChannelSettings_Controls     :=
-                                             c_ChannelSettings_Controls_EnhancedMode * BYTE(1) +
-                                             c_ChannelSettings_Controls_SurroundMode * BYTE(0);
-      END
-     ELSE
-      BEGIN
-      { *** channel disabled }
-       Module^.Module_ChannelSettingPointer^[I1].ChannelSettings_GlobalVolume := $00;
-       Module^.Module_ChannelSettingPointer^[I1].ChannelSettings_Panning      := $00;
-       Module^.Module_ChannelSettingPointer^[I1].ChannelSettings_Code         := $00;
-       Module^.Module_ChannelSettingPointer^[I1].ChannelSettings_Controls     := $00;
-      END;
-    END;
-  { *** init and copy order }
-   FILLCHAR(Module^.Module_OrderPointer^,c_Maximum_OrderIndex+1,$FF);
-   MOVE(Order^,Module^.Module_OrderPointer^,Header^.PSM_OrderLength);
-  { *** read pattern }
-   SEEK(InFile,FilePosition + Header^.PSM_PatternPosition);
-   NTMIK_LoaderPatternNumber := Header^.PSM_PatternNumber-1;
-   FOR I1 := 0 TO Header^.PSM_PatternNumber-1 DO
-    BEGIN
-     NTMIK_LoadPatternProcedure;
-    { *** read length }
-     BLOCKREAD(InFile,TempW,2);
-    { *** read pattern }
-     BLOCKREAD(InFile,MultiPurposeBuffer^,TempW-2);
-    { *** unpack pattern and set notes per channel to 64 }
-     PSM_UnpackPattern(MultiPurposeBuffer^,PatternBuffer^,TempW);
-     NTMIK_PackPattern(MultiPurposeBuffer^,PatternBuffer^,PSM_NotesInPattern);
-     TempW := WORD(256) * MultiPurposeBuffer^[01] + MultiPurposeBuffer^[00];
-     GETMEM(Module^.Module_PatternPointer^[I1],TempW);
-     MOVE(MultiPurposeBuffer^,Module^.Module_PatternPointer^[I1]^,TempW);
-    { *** next pattern }
-    END;
-  { *** read samples }
-   NTMIK_LoaderSampleNumber := Header^.PSM_SampleNumber;
-   FOR I1 := 1 TO Header^.PSM_SampleNumber DO
-    BEGIN
-     NTMIK_LoadSampleProcedure;
-    { *** get index for sample }
-     I3 := Sample^[I1].PSM_SampleNumber;
-    { *** clip PSM-sample }
-     IF Sample^[I1].PSM_SampleLoopEnd > Sample^[I1].PSM_SampleLength
-     THEN Sample^[I1].PSM_SampleLoopEnd := Sample^[I1].PSM_SampleLength;
-    { *** init intern sample }
-     NEW(Module^.Module_SamplePointer^[I3]);
-     FILLCHAR(Module^.Module_SamplePointer^[I3]^,SIZEOF(TSample),$00);
-     FILLCHAR(Module^.Module_SamplePointer^[I3]^.Sample_SampleName,c_Sample_SampleNameLength,#32);
-     FILLCHAR(Module^.Module_SamplePointer^[I3]^.Sample_FileName,c_Sample_FileNameLength,#32);
-    { *** copy informations to intern sample }
-     I2 := $01;
-     WHILE (Sample^[I1].PSM_SampleName[I2] > #00) AND (I2 < c_Sample_SampleNameLength) DO
-      BEGIN
-       Module^.Module_SamplePointer^[I3]^.Sample_SampleName[I2] := Sample^[I1].PSM_SampleName[I2];
-       INC(I2);
-      END;
-     Module^.Module_SamplePointer^[I3]^.Sample_Sign              := 'DF';
-     Module^.Module_SamplePointer^[I3]^.Sample_FileFormatVersion := $00100;
-     Module^.Module_SamplePointer^[I3]^.Sample_Position          := $00000000;
-     Module^.Module_SamplePointer^[I3]^.Sample_Selector          := $0000;
-     Module^.Module_SamplePointer^[I3]^.Sample_Volume            := Sample^[I1].PSM_SampleVolume;
-     Module^.Module_SamplePointer^[I3]^.Sample_LoopCounter       := $00;
-     Module^.Module_SamplePointer^[I3]^.Sample_C5Speed           := Sample^[I1].PSM_SampleC5Speed;
-     Module^.Module_SamplePointer^[I3]^.Sample_Length            := Sample^[I1].PSM_SampleLength;
-     Module^.Module_SamplePointer^[I3]^.Sample_LoopBegin         := Sample^[I1].PSM_SampleLoopBegin;
-     Module^.Module_SamplePointer^[I3]^.Sample_LoopEnd           := Sample^[I1].PSM_SampleLoopEnd;
-    { *** now it's time for the flags }
-     Module^.Module_SamplePointer^[I3]^.Sample_Flags :=
-                                 c_Sample_Flags_DigitalSample      * BYTE(1) +
-                                 c_Sample_Flags_8BitSample         * BYTE(1) +
-                                 c_Sample_Flags_UnsignedSampleData * BYTE(1) +
-                                 c_Sample_Flags_Packed             * BYTE(0) +
-                                 c_Sample_Flags_LoopCounter        * BYTE(0) +
-                                 c_Sample_Flags_SampleName         * BYTE(1) +
-                                 c_Sample_Flags_LoopActive         *
-                             BYTE(Sample^[I1].PSM_SampleFlags AND (LONGINT(1) SHL 15) = (LONGINT(1) SHL 15));
-    { *** alloc memory for sample-data }
-     E_Getmem(Module^.Module_SamplePointer^[I3]^.Sample_Selector,
-              Module^.Module_SamplePointer^[I3]^.Sample_Position,
-              Module^.Module_SamplePointer^[I3]^.Sample_Length + c_LoopExtensionSize);
-    { *** read out data }
-     EPT(TempP).p_Selector := Module^.Module_SamplePointer^[I3]^.Sample_Selector;
-     EPT(TempP).p_Offset   := $0000;
-     SEEK(InFile,Sample^[I1].PSM_SamplePosition);
-     E_BLOCKREAD(InFile,TempP^,Module^.Module_SamplePointer^[I3]^.Sample_Length);
-    { *** 'coz the samples are signed in a DSM-file -> PC-fy them }
-     IF Module^.Module_SamplePointer^[I3]^.Sample_Length > 4 THEN
-      BEGIN
-       CopyLength := Module^.Module_SamplePointer^[I3]^.Sample_Length;
-      { *** decode sample }
-       ASM
-        DB 066h; MOV CX,WORD PTR CopyLength
-       { *** load sample selector }
-                 MOV ES,WORD PTR TempP[00002h]
-        DB 066h; XOR SI,SI
-        DB 066h; XOR DI,DI
-                 XOR AH,AH
-       { *** conert all bytes }
-                @@MainLoop:
-        DB 026h; DB 067h; LODSB
-                 ADD AL,AH
-                 MOV AH,AL
-        DB 067h; STOSB
-        DB 066h; LOOP @@MainLoop
-       END;
-      { *** make samples unsigned }
-       ASM
-        DB 066h; MOV CX,WORD PTR CopyLength
-       { *** load sample selector }
-                 MOV ES,WORD PTR TempP[00002h]
-        DB 066h; XOR SI,SI
-        DB 066h; XOR DI,DI
-       { *** conert all bytes }
-                @@MainLoop:
-        DB 026h; DB 067h; LODSB
-                 SUB AL,080h
-        DB 067h; STOSB
-        DB 066h; LOOP @@MainLoop
-       END;
-      { *** Create Loop-Extension }
-       IF Module^.Module_SamplePointer^[I3]^.Sample_Flags AND c_Sample_Flags_LoopActive = c_Sample_Flags_LoopActive THEN
-        BEGIN
-         CopySource      := Module^.Module_SamplePointer^[I3]^.Sample_LoopBegin;
-         CopyDestination := Module^.Module_SamplePointer^[I3]^.Sample_LoopEnd;
-         CopyLength      := CopyDestination - CopySource;
-         ASM
-         { *** load sample-selector }
-                   MOV ES,WORD PTR TempP[00002h]
-          DB 066h; MOV DI,WORD PTR CopyDestination
-         { *** calculate number of full sample-loops to copy }
-                   XOR DX,DX
-                   MOV AX,c_LoopExtensionSize
-                   MOV BX,WORD PTR CopyLength
-                   DIV BX
-                   OR AX,AX
-                   JE @@NoFullLoop
-         { *** copy some full-loops (size=bx) }
-                   MOV CX,AX
-                  @@InnerLoop:
-                   PUSH CX
-          DB 066h; MOV SI,WORD PTR CopySource
-                   MOV CX,BX
-          DB 0F3h; DB 026h,067h,0A4h { REP MOVS BYTE PTR ES:[EDI],ES:[ESI] }
-                   POP CX
-                   LOOP @@InnerLoop
-                  @@NoFullLoop:
-         { *** calculate number of rest-bytes to copy }
-          DB 066h; MOV SI,WORD PTR CopySource
-                   MOV CX,DX
-          DB 0F3h; DB 026h,067h,0A4h { REP MOVS BYTE PTR ES:[EDI],ES:[ESI] }
-         END;
-        END
-       ELSE
-        BEGIN
-         CopyDestination := Module^.Module_SamplePointer^[I3]^.Sample_Length;
-         ASM
-         { *** load sample-selector }
-                   MOV ES,WORD PTR TempP[00002h]
-          DB 066h; MOV DI,WORD PTR CopyDestination
-         { *** clear extension }
-                   MOV CX,c_LoopExtensionSize
-                   MOV AL,080h
-          DB 0F3h; DB 067h,0AAh       { REP STOS BYTE PTR ES:[EDI] }
-         END;
-        END;
-      END;
-    { *** next sample }
-    END;
-  { *** init period-ranges }
-   NTMIK_MaximumPeriod := $0000D600 SHR 1;
-   NTMIK_MinimumPeriod := $0000D600 SHR 8;
-  { *** close file }
-   CLOSE(InFile);
-  { *** dispose all dynamic variables }
-   DISPOSE(Header);
-   DISPOSE(Sample);
-   DISPOSE(Order);
-   DISPOSE(ChannelSettings);
-   DISPOSE(MultiPurposeBuffer);
-   DISPOSE(PatternBuffer);
-  { *** set errorcode to noerror }
-   ErrorCode := c_NoError;
-  END;
-
-*/
diff --git a/src/load_s3m.cpp b/src/load_s3m.cpp
index 121da12..136357a 100644
--- a/src/load_s3m.cpp
+++ b/src/load_s3m.cpp
@@ -39,7 +39,6 @@ typedef struct tagS3MSAMPLESTRUCT
 	CHAR scrs[4];
 } S3MSAMPLESTRUCT;
 
-
 typedef struct tagS3MFILEHEADER
 {
 	CHAR name[28];
@@ -63,6 +62,7 @@ typedef struct tagS3MFILEHEADER
 	WORD special;
 	BYTE channels[32];
 } S3MFILEHEADER;
+#pragma pack()
 
 
 void CSoundFile::S3MConvert(MODCOMMAND *m, BOOL bIT) const
@@ -104,85 +104,6 @@ void CSoundFile::S3MConvert(MODCOMMAND *m, BOOL bIT) const
 	m->param = param;
 }
 
-
-void CSoundFile::S3MSaveConvert(UINT *pcmd, UINT *pprm, BOOL bIT) const
-//---------------------------------------------------------------------
-{
-	UINT command = *pcmd;
-	UINT param = *pprm;
-	switch(command)
-	{
-	case CMD_SPEED:				command = 'A'; break;
-	case CMD_POSITIONJUMP:		command = 'B'; break;
-	case CMD_PATTERNBREAK:		command = 'C'; if (!bIT) param = ((param / 10) << 4) + (param % 10); break;
-	case CMD_VOLUMESLIDE:		command = 'D'; break;
-	case CMD_PORTAMENTODOWN:	command = 'E'; if ((param >= 0xE0) && (m_nType & (MOD_TYPE_MOD|MOD_TYPE_XM))) param = 0xDF; break;
-	case CMD_PORTAMENTOUP:		command = 'F'; if ((param >= 0xE0) && (m_nType & (MOD_TYPE_MOD|MOD_TYPE_XM))) param = 0xDF; break;
-	case CMD_TONEPORTAMENTO:	command = 'G'; break;
-	case CMD_VIBRATO:			command = 'H'; break;
-	case CMD_TREMOR:			command = 'I'; break;
-	case CMD_ARPEGGIO:			command = 'J'; break;
-	case CMD_VIBRATOVOL:		command = 'K'; break;
-	case CMD_TONEPORTAVOL:		command = 'L'; break;
-	case CMD_CHANNELVOLUME:		command = 'M'; break;
-	case CMD_CHANNELVOLSLIDE:	command = 'N'; break;
-	case CMD_OFFSET:			command = 'O'; break;
-	case CMD_PANNINGSLIDE:		command = 'P'; break;
-	case CMD_RETRIG:			command = 'Q'; break;
-	case CMD_TREMOLO:			command = 'R'; break;
-	case CMD_S3MCMDEX:			command = 'S'; break;
-	case CMD_TEMPO:				command = 'T'; break;
-	case CMD_FINEVIBRATO:		command = 'U'; break;
-	case CMD_GLOBALVOLUME:		command = 'V'; break;
-	case CMD_GLOBALVOLSLIDE:	command = 'W'; break;
-	case CMD_PANNING8:
-		command = 'X';
-		if ((bIT) && (m_nType != MOD_TYPE_IT) && (m_nType != MOD_TYPE_XM))
-		{
-			if (param == 0xA4) { command = 'S'; param = 0x91; }	else
-			if (param <= 0x80) { param <<= 1; if (param > 255) param = 255; } else
-			command = param = 0;
-		} else
-		if ((!bIT) && ((m_nType == MOD_TYPE_IT) || (m_nType == MOD_TYPE_XM)))
-		{
-			param >>= 1;
-		}
-		break;
-	case CMD_PANBRELLO:			command = 'Y'; break;
-	case CMD_MIDI:				command = 'Z'; break;
-	case CMD_XFINEPORTAUPDOWN:
-		if (param & 0x0F) switch(param & 0xF0)
-		{
-		case 0x10:	command = 'F'; param = (param & 0x0F) | 0xE0; break;
-		case 0x20:	command = 'E'; param = (param & 0x0F) | 0xE0; break;
-		case 0x90:	command = 'S'; break;
-		default:	command = param = 0;
-		} else command = param = 0;
-		break;
-	case CMD_MODCMDEX:
-		command = 'S';
-		switch(param & 0xF0)
-		{
-		case 0x00:	command = param = 0; break;
-		case 0x10:	command = 'F'; param |= 0xF0; break;
-		case 0x20:	command = 'E'; param |= 0xF0; break;
-		case 0x30:	param = (param & 0x0F) | 0x10; break;
-		case 0x40:	param = (param & 0x0F) | 0x30; break;
-		case 0x50:	param = (param & 0x0F) | 0x20; break;
-		case 0x60:	param = (param & 0x0F) | 0xB0; break;
-		case 0x70:	param = (param & 0x0F) | 0x40; break;
-		case 0x90:	command = 'Q'; param &= 0x0F; break;
-		case 0xA0:	if (param & 0x0F) { command = 'D'; param = (param << 4) | 0x0F; } else command=param=0; break;
-		case 0xB0:	if (param & 0x0F) { command = 'D'; param |= 0xF0; } else command=param=0; break;
-		}
-		break;
-	default:	command = param = 0;
-	}
-	command &= ~0x40;
-	*pcmd = command;
-	*pprm = param;
-}
-
 static DWORD boundInput(DWORD input, DWORD smin, DWORD smax)
 {
 	if (input > smax) input = smax;
@@ -190,7 +111,6 @@ static DWORD boundInput(DWORD input, DWORD smin, DWORD smax)
 	return(input);
 }
 
-
 BOOL CSoundFile::ReadS3M(const BYTE *lpStream, DWORD dwMemLength)
 //---------------------------------------------------------------
 {
@@ -299,7 +219,7 @@ BOOL CSoundFile::ReadS3M(const BYTE *lpStream, DWORD dwMemLength)
 		}
 		S3MSAMPLESTRUCT pSmp;
 		memcpy(&pSmp, lpStream+nInd, 0x50);
-		memcpy(Ins[iSmp].name, &pSmp.dosname, 12);
+		memcpy(Ins[iSmp].name, pSmp.dosname, 12);
 		insflags[iSmp-1] = pSmp.flags;
 		inspack[iSmp-1] = pSmp.pack;
 		memcpy(m_szNames[iSmp], pSmp.name, 28);
@@ -410,261 +330,3 @@ BOOL CSoundFile::ReadS3M(const BYTE *lpStream, DWORD dwMemLength)
 	if (psfh.flags & 0x10) m_dwSongFlags |= SONG_AMIGALIMITS;
 	return TRUE;
 }
-
-
-#ifndef MODPLUG_NO_FILESAVE
-
-#ifdef _MSC_VER
-#pragma warning(disable:4100)
-#endif
-
-static BYTE S3MFiller[16] =
-{
-	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80
-};
-
-
-BOOL CSoundFile::SaveS3M(LPCSTR lpszFileName, UINT nPacking)
-//----------------------------------------------------------
-{
-	FILE *f;
-	BYTE header[0x60];
-	UINT nbo,nbi,nbp,i;
-	WORD patptr[128];
-	WORD insptr[128];
-	BYTE buffer[5*1024];
-	S3MSAMPLESTRUCT insex[128];
-
-	if ((!m_nChannels) || (!lpszFileName)) return FALSE;
-	if ((f = fopen(lpszFileName, "wb")) == NULL) return FALSE;
-	// Writing S3M header
-	memset(header, 0, sizeof(header));
-	memset(insex, 0, sizeof(insex));
-	memcpy(header, m_szNames[0], 0x1C);
-	header[0x1B] = 0;
-	header[0x1C] = 0x1A;
-	header[0x1D] = 0x10;
-	nbo = (GetNumPatterns() + 15) & 0xF0;
-	if (!nbo) nbo = 16;
-	header[0x20] = nbo & 0xFF;
-	header[0x21] = nbo >> 8;
-	nbi = m_nInstruments;
-	if (!nbi) nbi = m_nSamples;
-	if (nbi > 99) nbi = 99;
-	header[0x22] = nbi & 0xFF;
-	header[0x23] = nbi >> 8;
-	nbp = 0;
-	for (i=0; Patterns[i]; i++) { nbp = i+1; if (nbp >= MAX_PATTERNS) break; }
-	for (i=0; i<MAX_ORDERS; i++) if ((Order[i] < MAX_PATTERNS) && (Order[i] >= nbp)) nbp = Order[i] + 1;
-	header[0x24] = nbp & 0xFF;
-	header[0x25] = nbp >> 8;
-	if (m_dwSongFlags & SONG_FASTVOLSLIDES) header[0x26] |= 0x40;
-	if ((m_nMaxPeriod < 20000) || (m_dwSongFlags & SONG_AMIGALIMITS)) header[0x26] |= 0x10;
-	header[0x28] = 0x20;
-	header[0x29] = 0x13;
-	header[0x2A] = 0x02; // Version = 1 => Signed samples
-	header[0x2B] = 0x00;
-	header[0x2C] = 'S';
-	header[0x2D] = 'C';
-	header[0x2E] = 'R';
-	header[0x2F] = 'M';
-	header[0x30] = m_nDefaultGlobalVolume >> 2;
-	header[0x31] = m_nDefaultSpeed;
-	header[0x32] = m_nDefaultTempo;
-	header[0x33] = ((m_nSongPreAmp < 0x20) ? 0x20 : m_nSongPreAmp) | 0x80;	// Stereo
-	header[0x35] = 0xFC;
-	for (i=0; i<32; i++)
-	{
-		if (i < m_nChannels)
-		{
-			UINT tmp = (i & 0x0F) >> 1;
-			header[0x40+i] = (i & 0x10) | ((i & 1) ? 8+tmp : tmp);
-		} else header[0x40+i] = 0xFF;
-	}
-	fwrite(header, 0x60, 1, f);
-	fwrite(Order, nbo, 1, f);
-	memset(patptr, 0, sizeof(patptr));
-	memset(insptr, 0, sizeof(insptr));
-	UINT ofs0 = 0x60 + nbo;
-	UINT ofs1 = ((0x60 + nbo + nbi*2 + nbp*2 + 15) & 0xFFF0) + 0x20;
-	UINT ofs = ofs1;
-
-	for (i=0; i<nbi; i++) insptr[i] = (WORD)((ofs + i*0x50) / 16);
-	for (i=0; i<nbp; i++) patptr[i] = (WORD)((ofs + nbi*0x50) / 16);
-	fwrite(insptr, nbi, 2, f);
-	fwrite(patptr, nbp, 2, f);
-	if (header[0x35] == 0xFC)
-	{
-		BYTE chnpan[32];
-		for (i=0; i<32; i++)
-		{
-			chnpan[i] = 0x20 | (ChnSettings[i].nPan >> 4);
-		}
-		fwrite(chnpan, 0x20, 1, f);
-	}
-	if ((nbi*2+nbp*2) & 0x0F)
-	{
-		fwrite(S3MFiller, 0x10 - ((nbi*2+nbp*2) & 0x0F), 1, f);
-	}
-	ofs1 = ftell(f);
-	fwrite(insex, nbi, 0x50, f);
-	// Packing patterns
-	ofs += nbi*0x50;
-	for (i=0; i<nbp; i++)
-	{
-		WORD len = 64;
-		memset(buffer, 0, sizeof(buffer));
-		patptr[i] = ofs / 16;
-		if (Patterns[i])
-		{
-			len = 2;
-			MODCOMMAND *p = Patterns[i];
-			for (int row=0; row<64; row++) if (row < PatternSize[i])
-			{
-				for (UINT j=0; j<m_nChannels; j++)
-				{
-					UINT b = j;
-					MODCOMMAND *m = &p[row*m_nChannels+j];
-					UINT note = m->note;
-					UINT volcmd = m->volcmd;
-					UINT vol = m->vol;
-					UINT command = m->command;
-					UINT param = m->param;
-
-					if ((note) || (m->instr)) b |= 0x20;
-					if (!note) note = 0xFF; else
-					if (note >= 0xFE) note = 0xFE; else
-					if (note < 13) note = 0; else note -= 13;
-					if (note < 0xFE) note = (note % 12) + ((note / 12) << 4);
-					if (command == CMD_VOLUME)
-					{
-						command = 0;
-						if (param > 64) param = 64;
-						volcmd = VOLCMD_VOLUME;
-						vol = param;
-					}
-					if (volcmd == VOLCMD_VOLUME) b |= 0x40; else
-					if (volcmd == VOLCMD_PANNING) { vol |= 0x80; b |= 0x40; }
-					if (command)
-					{
-						S3MSaveConvert(&command, &param, FALSE);
-						if (command) b |= 0x80;
-					}
-					if (b & 0xE0)
-					{
-						buffer[len++] = b;
-						if (b & 0x20)
-						{
-							buffer[len++] = note;
-							buffer[len++] = m->instr;
-						}
-						if (b & 0x40)
-						{
-							buffer[len++] = vol;
-						}
-						if (b & 0x80)
-						{
-							buffer[len++] = command;
-							buffer[len++] = param;
-						}
-						if (len > sizeof(buffer) - 20) break;
-					}
-				}
-				buffer[len++] = 0;
-				if (len > sizeof(buffer) - 20) break;
-			}
-		}
-		buffer[0] = (len - 2) & 0xFF;
-		buffer[1] = (len - 2) >> 8;
-		len = (len+15) & (~0x0F);
-		fwrite(buffer, len, 1, f);
-		ofs += len;
-	}
-	// Writing samples
-	for (i=1; i<=nbi; i++)
-	{
-		MODINSTRUMENT *pins = &Ins[i];
-		if (m_nInstruments)
-		{
-			pins = Ins;
-			if (Headers[i])
-			{
-				for (UINT j=0; j<128; j++)
-				{
-					UINT n = Headers[i]->Keyboard[j];
-					if ((n) && (n < MAX_INSTRUMENTS))
-					{
-						pins = &Ins[n];
-						break;
-					}
-				}
-			}
-		}
-		memcpy(insex[i-1].dosname, pins->name, 12);
-		memcpy(insex[i-1].name, m_szNames[i], 28);
-		memcpy(insex[i-1].scrs, "SCRS", 4);
-		insex[i-1].hmem = (BYTE)((DWORD)ofs >> 20);
-		insex[i-1].memseg = (WORD)((DWORD)ofs >> 4);
-		if (pins->pSample)
-		{
-			insex[i-1].type = 1;
-			insex[i-1].length = pins->nLength;
-			insex[i-1].loopbegin = pins->nLoopStart;
-			insex[i-1].loopend = pins->nLoopEnd;
-			insex[i-1].vol = pins->nVolume / 4;
-			insex[i-1].flags = (pins->uFlags & CHN_LOOP) ? 1 : 0;
-			if (pins->nC4Speed)
-				insex[i-1].finetune = pins->nC4Speed;
-			else
-				insex[i-1].finetune = TransposeToFrequency(pins->RelativeTone, pins->nFineTune);
-			UINT flags = RS_PCM8U;
-#ifndef NO_PACKING
-			if (nPacking)
-			{
-				if ((!(pins->uFlags & (CHN_16BIT|CHN_STEREO)))
-				 && (CanPackSample((char *)pins->pSample, pins->nLength, nPacking)))
-				{
-					insex[i-1].pack = 4;
-					flags = RS_ADPCM4;
-				}
-			} else
-#endif // NO_PACKING
-			{
-				if (pins->uFlags & CHN_16BIT)
-				{
-					insex[i-1].flags |= 4;
-					flags = RS_PCM16U;
-				}
-				if (pins->uFlags & CHN_STEREO)
-				{
-					insex[i-1].flags |= 2;
-					flags = (pins->uFlags & CHN_16BIT) ? RS_STPCM16U : RS_STPCM8U;
-				}
-			}
-			DWORD len = WriteSample(f, pins, flags);
-			if (len & 0x0F)
-			{
-				fwrite(S3MFiller, 0x10 - (len & 0x0F), 1, f);
-			}
-			ofs += (len + 15) & (~0x0F);
-		} else
-		{
-			insex[i-1].length = 0;
-		}
-	}
-	// Updating parapointers
-	fseek(f, ofs0, SEEK_SET);
-	fwrite(insptr, nbi, 2, f);
-	fwrite(patptr, nbp, 2, f);
-	fseek(f, ofs1, SEEK_SET);
-	fwrite(insex, 0x50, nbi, f);
-	fclose(f);
-	return TRUE;
-}
-
-#ifdef _MSC_VER
-#pragma warning(default:4100)
-#endif
-
-#endif // MODPLUG_NO_FILESAVE
diff --git a/src/load_stm.cpp b/src/load_stm.cpp
index 6f55b78..8b0ca0f 100644
--- a/src/load_stm.cpp
+++ b/src/load_stm.cpp
@@ -64,8 +64,8 @@ BOOL CSoundFile::ReadSTM(const BYTE *lpStream, DWORD dwMemLength)
 	
 	if ((!lpStream) || (dwMemLength < sizeof(STMHEADER))) return FALSE;
 	if ((phdr->filetype != 2) || (phdr->unused != 0x1A)
-	 || ((strncasecmp(phdr->trackername, "!SCREAM!", 8))
-	  && (strncasecmp(phdr->trackername, "BMOD2STM", 8)))) return FALSE;
+	 || ((strncmp(phdr->trackername, "!Scream!", 8))
+	  && (strncmp(phdr->trackername, "BMOD2STM", 8)))) return FALSE;
 	memcpy(m_szNames[0], phdr->songname, 20);
 	// Read STM header
 	m_nType = MOD_TYPE_STM;
diff --git a/src/load_wav.cpp b/src/load_wav.cpp
index cf721df..e6232e9 100644
--- a/src/load_wav.cpp
+++ b/src/load_wav.cpp
@@ -7,6 +7,12 @@
 #include "stdafx.h"
 #include "sndfile.h"
 
+#ifndef WAV_SUPPORT
+BOOL CSoundFile::ReadWav(const BYTE *lpStream,DWORD dwMemLength) {
+	return FALSE;
+}
+#else
+
 #ifndef WAVE_FORMAT_EXTENSIBLE
 #define WAVE_FORMAT_EXTENSIBLE	0xFFFE
 #endif
@@ -139,19 +145,16 @@ BOOL CSoundFile::ReadWav(const BYTE *lpStream, DWORD dwMemLength)
 	return TRUE;
 }
 
-
 ////////////////////////////////////////////////////////////////////////
 // IMA ADPCM Support
 
 #pragma pack(1)
-
 typedef struct IMAADPCMBLOCK
 {
 	WORD sample;
 	BYTE index;
 	BYTE Reserved;
 } DVI_ADPCMBLOCKHEADER;
-
 #pragma pack()
 
 static const int gIMAUnpackTable[90] =
@@ -170,7 +173,6 @@ static const int gIMAUnpackTable[90] =
   32767, 0
 };
 
-
 BOOL IMAADPCMUnpack16(signed short *pdest, UINT nLen, LPBYTE psrc, DWORD dwBytes, UINT pkBlkAlign)
 //------------------------------------------------------------------------------------------------
 {
@@ -215,3 +217,4 @@ BOOL IMAADPCMUnpack16(signed short *pdest, UINT nLen, LPBYTE psrc, DWORD dwBytes
 	}
 	return TRUE;
 }
+#endif // WAV_SUPPORT
diff --git a/src/load_xm.cpp b/src/load_xm.cpp
index 3a22b7d..531b1d6 100644
--- a/src/load_xm.cpp
+++ b/src/load_xm.cpp
@@ -11,7 +11,7 @@
 ////////////////////////////////////////////////////////
 // FastTracker II XM file support
 
-#ifdef MSC_VER
+#ifdef _MSC_VER
 #pragma warning(disable:4244)
 #endif
 
@@ -30,7 +30,6 @@ typedef struct tagXMFILEHEADER
 	BYTE order[256];
 } XMFILEHEADER;
 
-
 typedef struct tagXMINSTRUMENTHEADER
 {
 	DWORD size;
@@ -40,7 +39,6 @@ typedef struct tagXMINSTRUMENTHEADER
 	BYTE samplesh;
 } XMINSTRUMENTHEADER;
 
-
 typedef struct tagXMSAMPLEHEADER
 {
 	DWORD shsize;
@@ -71,7 +69,6 @@ typedef struct tagXMSAMPLESTRUCT
 } XMSAMPLESTRUCT;
 #pragma pack()
 
-
 BOOL CSoundFile::ReadXM(const BYTE *lpStream, DWORD dwMemLength)
 //--------------------------------------------------------------
 {
@@ -582,315 +579,3 @@ BOOL CSoundFile::ReadXM(const BYTE *lpStream, DWORD dwMemLength)
 	}
 	return TRUE;
 }
-
-
-#ifndef MODPLUG_NO_FILESAVE
-
-BOOL CSoundFile::SaveXM(LPCSTR lpszFileName, UINT nPacking)
-//---------------------------------------------------------
-{
-	BYTE s[64*64*5];
-	XMFILEHEADER header;
-	XMINSTRUMENTHEADER xmih;
-	XMSAMPLEHEADER xmsh;
-	XMSAMPLESTRUCT xmss;
-	BYTE smptable[32];
-	BYTE xmph[9];
-	FILE *f;
-	int i;
-
-	if ((!m_nChannels) || (!lpszFileName)) return FALSE;
-	if ((f = fopen(lpszFileName, "wb")) == NULL) return FALSE;
-	fwrite("Extended Module: ", 17, 1, f);
-	fwrite(m_szNames[0], 20, 1, f);
-	s[0] = 0x1A;
-	lstrcpy((LPSTR)&s[1], (nPacking) ? "MOD Plugin packed   " : "FastTracker v2.00   ");
-	s[21] = 0x04;
-	s[22] = 0x01;
-	fwrite(s, 23, 1, f);
-	// Writing song header
-	memset(&header, 0, sizeof(header));
-	header.size = sizeof(XMFILEHEADER);
-	header.norder = 0;
-	header.restartpos = m_nRestartPos;
-	header.channels = m_nChannels;
-	header.patterns = 0;
-	for (i=0; i<MAX_ORDERS; i++)
-	{
-		if (Order[i] == 0xFF) break;
-		header.norder++;
-		if ((Order[i] >= header.patterns) && (Order[i] < MAX_PATTERNS)) header.patterns = Order[i]+1;
-	}
-	header.instruments = m_nInstruments;
-	if (!header.instruments) header.instruments = m_nSamples;
-	header.flags = (m_dwSongFlags & SONG_LINEARSLIDES) ? 0x01 : 0x00;
-	if (m_dwSongFlags & SONG_EXFILTERRANGE) header.flags |= 0x1000;
-	header.tempo = m_nDefaultTempo;
-	header.speed = m_nDefaultSpeed;
-	memcpy(header.order, Order, header.norder);
-	fwrite(&header, 1, sizeof(header), f);
-	// Writing patterns
-	for (i=0; i<header.patterns; i++) if (Patterns[i])
-	{
-		MODCOMMAND *p = Patterns[i];
-		UINT len = 0;
-
-		memset(&xmph, 0, sizeof(xmph));
-		xmph[0] = 9;
-		xmph[5] = (BYTE)(PatternSize[i] & 0xFF);
-		xmph[6] = (BYTE)(PatternSize[i] >> 8);
-		for (UINT j=m_nChannels*PatternSize[i]; j; j--,p++)
-		{
-			UINT note = p->note;
-			UINT param = ModSaveCommand(p, TRUE);
-			UINT command = param >> 8;
-			param &= 0xFF;
-			if (note >= 0xFE) note = 97; else
-			if ((note <= 12) || (note > 96+12)) note = 0; else
-			note -= 12;
-			UINT vol = 0;
-			if (p->volcmd)
-			{
-				UINT volcmd = p->volcmd;
-				switch(volcmd)
-				{
-				case VOLCMD_VOLUME:			vol = 0x10 + p->vol; break;
-				case VOLCMD_VOLSLIDEDOWN:	vol = 0x60 + (p->vol & 0x0F); break;
-				case VOLCMD_VOLSLIDEUP:		vol = 0x70 + (p->vol & 0x0F); break;
-				case VOLCMD_FINEVOLDOWN:	vol = 0x80 + (p->vol & 0x0F); break;
-				case VOLCMD_FINEVOLUP:		vol = 0x90 + (p->vol & 0x0F); break;
-				case VOLCMD_VIBRATOSPEED:	vol = 0xA0 + (p->vol & 0x0F); break;
-				case VOLCMD_VIBRATO:		vol = 0xB0 + (p->vol & 0x0F); break;
-				case VOLCMD_PANNING:		vol = 0xC0 + (p->vol >> 2); if (vol > 0xCF) vol = 0xCF; break;
-				case VOLCMD_PANSLIDELEFT:	vol = 0xD0 + (p->vol & 0x0F); break;
-				case VOLCMD_PANSLIDERIGHT:	vol = 0xE0 + (p->vol & 0x0F); break;
-				case VOLCMD_TONEPORTAMENTO:	vol = 0xF0 + (p->vol & 0x0F); break;
-				}
-			}
-			if ((note) && (p->instr) && (vol > 0x0F) && (command) && (param))
-			{
-				s[len++] = note;
-				s[len++] = p->instr;
-				s[len++] = vol;
-				s[len++] = command;
-				s[len++] = param;
-			} else
-			{
-				BYTE b = 0x80;
-				if (note) b |= 0x01;
-				if (p->instr) b |= 0x02;
-				if (vol >= 0x10) b |= 0x04;
-				if (command) b |= 0x08;
-				if (param) b |= 0x10;
-				s[len++] = b;
-				if (b & 1) s[len++] = note;
-				if (b & 2) s[len++] = p->instr;
-				if (b & 4) s[len++] = vol;
-				if (b & 8) s[len++] = command;
-				if (b & 16) s[len++] = param;
-			}
-			if (len > sizeof(s) - 5) break;
-		}
-		xmph[7] = (BYTE)(len & 0xFF);
-		xmph[8] = (BYTE)(len >> 8);
-		fwrite(xmph, 1, 9, f);
-		fwrite(s, 1, len, f);
-	} else
-	{
-		memset(&xmph, 0, sizeof(xmph));
-		xmph[0] = 9;
-		xmph[5] = (BYTE)(PatternSize[i] & 0xFF);
-		xmph[6] = (BYTE)(PatternSize[i] >> 8);
-		fwrite(xmph, 1, 9, f);
-	}
-	// Writing instruments
-	for (i=1; i<=header.instruments; i++)
-	{
-		MODINSTRUMENT *pins;
-		BYTE flags[32];
-
-		memset(&xmih, 0, sizeof(xmih));
-		memset(&xmsh, 0, sizeof(xmsh));
-		xmih.size = sizeof(xmih) + sizeof(xmsh);
-		memcpy(xmih.name, m_szNames[i], 22);
-		xmih.type = 0;
-		xmih.samples = 0;
-		if (m_nInstruments)
-		{
-			INSTRUMENTHEADER *penv = Headers[i];
-			if (penv)
-			{
-				memcpy(xmih.name, penv->name, 22);
-				xmih.type = penv->nMidiProgram;
-				xmsh.volfade = penv->nFadeOut;
-				xmsh.vnum = (BYTE)penv->nVolEnv;
-				xmsh.pnum = (BYTE)penv->nPanEnv;
-				if (xmsh.vnum > 12) xmsh.vnum = 12;
-				if (xmsh.pnum > 12) xmsh.pnum = 12;
-				for (UINT ienv=0; ienv<12; ienv++)
-				{
-					xmsh.venv[ienv*2] = penv->VolPoints[ienv];
-					xmsh.venv[ienv*2+1] = penv->VolEnv[ienv];
-					xmsh.penv[ienv*2] = penv->PanPoints[ienv];
-					xmsh.penv[ienv*2+1] = penv->PanEnv[ienv];
-				}
-				if (penv->dwFlags & ENV_VOLUME) xmsh.vtype |= 1;
-				if (penv->dwFlags & ENV_VOLSUSTAIN) xmsh.vtype |= 2;
-				if (penv->dwFlags & ENV_VOLLOOP) xmsh.vtype |= 4;
-				if (penv->dwFlags & ENV_PANNING) xmsh.ptype |= 1;
-				if (penv->dwFlags & ENV_PANSUSTAIN) xmsh.ptype |= 2;
-				if (penv->dwFlags & ENV_PANLOOP) xmsh.ptype |= 4;
-				xmsh.vsustain = (BYTE)penv->nVolSustainBegin;
-				xmsh.vloops = (BYTE)penv->nVolLoopStart;
-				xmsh.vloope = (BYTE)penv->nVolLoopEnd;
-				xmsh.psustain = (BYTE)penv->nPanSustainBegin;
-				xmsh.ploops = (BYTE)penv->nPanLoopStart;
-				xmsh.ploope = (BYTE)penv->nPanLoopEnd;
-				for (UINT j=0; j<96; j++) if (penv->Keyboard[j+12])
-				{
-					UINT k;
-					for (k=0; k<xmih.samples; k++)	if (smptable[k] == penv->Keyboard[j+12]) break;
-					if (k == xmih.samples)
-					{
-						smptable[xmih.samples++] = penv->Keyboard[j+12];
-					}
-					if (xmih.samples >= 32) break;
-					xmsh.snum[j] = k;
-				}
-//				xmsh.reserved2 = xmih.samples;
-			}
-		} else
-		{
-			xmih.samples = 1;
-//			xmsh.reserved2 = 1;
-			smptable[0] = i;
-		}
-		xmsh.shsize = (xmih.samples) ? 40 : 0;
-		fwrite(&xmih, 1, sizeof(xmih), f);
-		if (smptable[0])
-		{
-			MODINSTRUMENT *pvib = &Ins[smptable[0]];
-			xmsh.vibtype = pvib->nVibType;
-			xmsh.vibsweep = pvib->nVibSweep;
-			xmsh.vibdepth = pvib->nVibDepth;
-			xmsh.vibrate = pvib->nVibRate;
-		}
-		fwrite(&xmsh, 1, xmih.size - sizeof(xmih), f);
-		if (!xmih.samples) continue;
-		for (UINT ins=0; ins<xmih.samples; ins++)
-		{
-			memset(&xmss, 0, sizeof(xmss));
-			if (smptable[ins]) memcpy(xmss.name, m_szNames[smptable[ins]], 22);
-			pins = &Ins[smptable[ins]];
-			xmss.samplen = pins->nLength;
-			xmss.loopstart = pins->nLoopStart;
-			xmss.looplen = pins->nLoopEnd - pins->nLoopStart;
-			xmss.vol = pins->nVolume / 4;
-			xmss.finetune = (char)pins->nFineTune;
-			xmss.type = 0;
-			if (pins->uFlags & CHN_LOOP) xmss.type = (pins->uFlags & CHN_PINGPONGLOOP) ? 2 : 1;
-			flags[ins] = RS_PCM8D;
-#ifndef NO_PACKING
-			if (nPacking)
-			{
-				if ((!(pins->uFlags & (CHN_16BIT|CHN_STEREO)))
-				 && (CanPackSample((char *)pins->pSample, pins->nLength, nPacking)))
-				{
-					flags[ins] = RS_ADPCM4;
-					xmss.res = 0xAD;
-				}
-			} else
-#endif
-			{
-				if (pins->uFlags & CHN_16BIT)
-				{
-					flags[ins] = RS_PCM16D;
-					xmss.type |= 0x10;
-					xmss.looplen *= 2;
-					xmss.loopstart *= 2;
-					xmss.samplen *= 2;
-				}
-				if (pins->uFlags & CHN_STEREO)
-				{
-					flags[ins] = (pins->uFlags & CHN_16BIT) ? RS_STPCM16D : RS_STPCM8D;
-					xmss.type |= 0x20;
-					xmss.looplen *= 2;
-					xmss.loopstart *= 2;
-					xmss.samplen *= 2;
-				}
-			}
-			xmss.pan = 255;
-			if (pins->nPan < 256) xmss.pan = (BYTE)pins->nPan;
-			xmss.relnote = (signed char)pins->RelativeTone;
-			fwrite(&xmss, 1, xmsh.shsize, f);
-		}
-		for (UINT ismpd=0; ismpd<xmih.samples; ismpd++)
-		{
-			pins = &Ins[smptable[ismpd]];
-			if (pins->pSample)
-			{
-#ifndef NO_PACKING
-				if ((flags[ismpd] == RS_ADPCM4) && (xmih.samples>1)) CanPackSample((char *)pins->pSample, pins->nLength, nPacking);
-#endif // NO_PACKING
-				WriteSample(f, pins, flags[ismpd]);
-			}
-		}
-	}
-	// Writing song comments
-	if ((m_lpszSongComments) && (m_lpszSongComments[0]))
-	{
-		DWORD d = 0x74786574;
-		fwrite(&d, 1, 4, f);
-		d = strlen(m_lpszSongComments);
-		fwrite(&d, 1, 4, f);
-		fwrite(m_lpszSongComments, 1, d, f);
-	}
-	// Writing midi cfg
-	if (m_dwSongFlags & SONG_EMBEDMIDICFG)
-	{
-		DWORD d = 0x4944494D;
-		fwrite(&d, 1, 4, f);
-		d = sizeof(MODMIDICFG);
-		fwrite(&d, 1, 4, f);
-		fwrite(&m_MidiCfg, 1, sizeof(MODMIDICFG), f);
-	}
-	// Writing Pattern Names
-	if ((m_nPatternNames) && (m_lpszPatternNames))
-	{
-		DWORD dwLen = m_nPatternNames * MAX_PATTERNNAME;
-		while ((dwLen >= MAX_PATTERNNAME) && (!m_lpszPatternNames[dwLen-MAX_PATTERNNAME])) dwLen -= MAX_PATTERNNAME;
-		if (dwLen >= MAX_PATTERNNAME)
-		{
-			DWORD d = 0x4d414e50;
-			fwrite(&d, 1, 4, f);
-			fwrite(&dwLen, 1, 4, f);
-			fwrite(m_lpszPatternNames, 1, dwLen, f);
-		}
-	}
-	// Writing Channel Names
-	{
-		UINT nChnNames = 0;
-		for (UINT inam=0; inam<m_nChannels; inam++)
-		{
-			if (ChnSettings[inam].szName[0]) nChnNames = inam+1;
-		}
-		// Do it!
-		if (nChnNames)
-		{
-			DWORD dwLen = nChnNames * MAX_CHANNELNAME;
-			DWORD d = 0x4d414e43;
-			fwrite(&d, 1, 4, f);
-			fwrite(&dwLen, 1, 4, f);
-			for (UINT inam=0; inam<nChnNames; inam++)
-			{
-				fwrite(ChnSettings[inam].szName, 1, MAX_CHANNELNAME, f);
-			}
-		}
-	}
-	// Save mix plugins information
-	SaveMixPlugins(f);
-	fclose(f);
-	return TRUE;
-}
-
-#endif // MODPLUG_NO_FILESAVE
diff --git a/src/mmcmp.cpp b/src/mmcmp.cpp
index 890df2f..2ad7a7b 100644
--- a/src/mmcmp.cpp
+++ b/src/mmcmp.cpp
@@ -8,6 +8,7 @@
 #include "stdafx.h"
 #include "sndfile.h"
 
+#ifdef MMCMP_SUPPORT
 BOOL PP20_Unpack(LPCBYTE *ppMemFile, LPDWORD pdwMemLength);
 
 #pragma pack(1)
@@ -175,7 +176,7 @@ BOOL MMCMP_Unpack(LPCBYTE *ppMemFile, LPDWORD pdwMemLength)
 	 || (!pmmh->nblocks) || (pmmh->filesize < 16) || (pmmh->filesize > 0x8000000)
 	 || (pmmh->blktable >= dwMemLength) || (pmmh->blktable + 4*pmmh->nblocks > dwMemLength)) return FALSE;
 	dwFileSize = pmmh->filesize;
-	if ((pBuffer = (LPBYTE)GlobalAllocPtr(GHND, (dwFileSize + 31) & ~15)) == NULL) return FALSE;
+	if ((pBuffer = (LPBYTE)calloc(1, (dwFileSize + 31) & ~15)) == NULL) return FALSE;
 	pblk_table = (const DWORD *)(lpMemFile+pmmh->blktable);
 	for (UINT nBlock=0; nBlock<pmmh->nblocks; nBlock++)
 	{
@@ -382,7 +383,7 @@ BOOL MMCMP_Unpack(LPCBYTE *ppMemFile, LPDWORD pdwMemLength)
 			}
 		} else
 		{
-			GlobalFreePtr(pBuffer);
+			free(pBuffer);
 			return FALSE;
 		}
 	}
@@ -495,9 +496,10 @@ BOOL PP20_Unpack(LPCBYTE *ppMemFile, LPDWORD pdwMemLength)
 	dwDstLen = (lpMemFile[dwMemLength-4]<<16) | (lpMemFile[dwMemLength-3]<<8) | (lpMemFile[dwMemLength-2]);
 	//Log("PP20 detected: Packed length=%d, Unpacked length=%d\n", dwMemLength, dwDstLen);
 	if ((dwDstLen < 512) || (dwDstLen > 0x400000) || (dwDstLen > 16*dwMemLength)) return FALSE;
-	if ((pBuffer = (LPBYTE)GlobalAllocPtr(GHND, (dwDstLen + 31) & ~15)) == NULL) return FALSE;
+	if ((pBuffer = (LPBYTE)calloc(1, (dwDstLen + 31) & ~15)) == NULL) return FALSE;
 	PP20_DoUnpack(lpMemFile+4, dwMemLength-4, pBuffer, dwDstLen);
 	*ppMemFile = pBuffer;
 	*pdwMemLength = dwDstLen;
 	return TRUE;
 }
+#endif /* MMCMP_SUPPORT */
diff --git a/src/modplug.cpp b/src/modplug.cpp
index bb4ab62..eb00003 100644
--- a/src/modplug.cpp
+++ b/src/modplug.cpp
@@ -187,28 +187,6 @@ char* ModPlug_GetMessage(ModPlugFile* file)
 	return file->mSoundFile.m_lpszSongComments;
 }
 
-#ifndef MODPLUG_NO_FILESAVE
-char ModPlug_ExportS3M(ModPlugFile* file,const char* filepath)
-{
-	return (char)file->mSoundFile.SaveS3M(filepath,0);
-}
-
-char ModPlug_ExportXM(ModPlugFile* file,const char* filepath)
-{
-	return (char)file->mSoundFile.SaveXM(filepath,0);
-}
-
-char ModPlug_ExportMOD(ModPlugFile* file,const char* filepath)
-{
-	return (char)file->mSoundFile.SaveMod(filepath,0);
-}
-
-char ModPlug_ExportIT(ModPlugFile* file,const char* filepath)
-{
-	return (char)file->mSoundFile.SaveIT(filepath,0);
-}
-#endif // MODPLUG_NO_FILESAVE
-
 unsigned int ModPlug_NumInstruments(ModPlugFile* file)
 {
 	return file->mSoundFile.m_nInstruments;
diff --git a/src/modplug.h b/src/modplug.h
index f7f78b7..64e157c 100644
--- a/src/modplug.h
+++ b/src/modplug.h
@@ -19,6 +19,12 @@ extern "C" {
 # else
 #   define MODPLUG_EXPORT __declspec(dllimport)			/* using libmodplug dll for windows */
 # endif
+#elif defined(__OS2__) && defined(__WATCOMC__)
+# if defined(MODPLUG_BUILD) && defined(__SW_BD)		/* building libmodplug as a dll for os/2 */
+#   define MODPLUG_EXPORT __declspec(dllexport)
+# else
+#   define MODPLUG_EXPORT					/* using dll or static libmodplug for os/2 */
+# endif
 #elif defined(MODPLUG_BUILD) && defined(SYM_VISIBILITY)
 #   define MODPLUG_EXPORT __attribute__((visibility("default")))
 #else
@@ -130,24 +136,6 @@ MODPLUG_EXPORT void ModPlug_SeekOrder(ModPlugFile* file,int order);
 MODPLUG_EXPORT int ModPlug_GetModuleType(ModPlugFile* file);
 MODPLUG_EXPORT char* ModPlug_GetMessage(ModPlugFile* file);
 
-#define MODPLUG_NO_FILESAVE /* experimental yet.  must match stdafx.h. */
-#ifndef MODPLUG_NO_FILESAVE
-/*
- * EXPERIMENTAL Export Functions
- */
-/*Export to a Scream Tracker 3 S3M module. EXPERIMENTAL (only works on Little-Endian platforms)*/
-MODPLUG_EXPORT char ModPlug_ExportS3M(ModPlugFile* file, const char* filepath);
-
-/*Export to an Extended Module (XM). EXPERIMENTAL (only works on Little-Endian platforms)*/
-MODPLUG_EXPORT char ModPlug_ExportXM(ModPlugFile* file, const char* filepath);
-
-/*Export to an Amiga MOD file. EXPERIMENTAL.*/
-MODPLUG_EXPORT char ModPlug_ExportMOD(ModPlugFile* file, const char* filepath);
-
-/*Export to an Impulse Tracker IT file. Should work OK in Little-Endian & Big-Endian platforms :-) */
-MODPLUG_EXPORT char ModPlug_ExportIT(ModPlugFile* file, const char* filepath);
-#endif /* MODPLUG_NO_FILESAVE */
-
 MODPLUG_EXPORT unsigned int ModPlug_NumInstruments(ModPlugFile* file);
 MODPLUG_EXPORT unsigned int ModPlug_NumSamples(ModPlugFile* file);
 MODPLUG_EXPORT unsigned int ModPlug_NumPatterns(ModPlugFile* file);
@@ -182,4 +170,4 @@ MODPLUG_EXPORT void ModPlug_UnloadMixerCallback(ModPlugFile* file) ;
 } /* extern "C" */
 #endif
 
-#endif
+#endif /* MODPLUG_H__INCLUDED */
diff --git a/src/snd_flt.cpp b/src/snd_flt.cpp
index f8a573c..510ef76 100644
--- a/src/snd_flt.cpp
+++ b/src/snd_flt.cpp
@@ -13,12 +13,11 @@
 
 #ifndef NO_FILTER
 
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 #define _ASM_MATH
 #endif
 
 #ifdef _ASM_MATH
-
 // pow(a,b) returns a^^b -> 2^^(b.log2(a))
 static float pow(float a, float b)
 {
@@ -42,7 +41,6 @@ static float pow(float a, float b)
 	return result;
 }
 
-
 #else
 
 #include <math.h>
diff --git a/src/snd_fx.cpp b/src/snd_fx.cpp
index 0ed4f88..845ecb3 100644
--- a/src/snd_fx.cpp
+++ b/src/snd_fx.cpp
@@ -9,7 +9,7 @@
 #include "sndfile.h"
 #include "tables.h"
 
-#ifdef MSC_VER
+#ifdef _MSC_VER
 #pragma warning(disable:4244)
 #endif
 
@@ -514,7 +514,6 @@ void CSoundFile::NoteChange(UINT nChn, int note, BOOL bPorta, BOOL bResetEnv)
 	if (!bPorta)
 	{
 		pChn->nVUMeter = 0x100;
-		pChn->nLeftVU = pChn->nRightVU = 0xFF;
 		pChn->dwFlags &= ~CHN_FILTER;
 		pChn->dwFlags |= CHN_FASTVOLRAMP;
 		pChn->nRetrigCount = 0;
@@ -1225,9 +1224,6 @@ BOOL CSoundFile::ProcessEffects()
 						if (m_nRepeatCount > 0) m_nRepeatCount--;
 					} else
 					{
-					#ifdef MODPLUG_TRACKER
-						if (gdwSoundSetup & SNDMIX_NOBACKWARDJUMPS)
-					#endif
 						// Backward jump disabled
 						bNoLoop = TRUE;
 						//reset repeat count incase there are multiple loops.
@@ -2074,7 +2070,6 @@ void CSoundFile::SetSpeed(UINT param)
 {
 	UINT max = (m_nType == MOD_TYPE_IT) ? 256 : 128;
 	// Modplug Tracker and Mod-Plugin don't do this check
-#ifndef MODPLUG_TRACKER
 #ifndef MODPLUG_FASTSOUNDLIB
 	// Big Hack!!!
 	if ((!param) || (param >= 0x80) || ((m_nType & (MOD_TYPE_MOD|MOD_TYPE_XM|MOD_TYPE_MT2)) && (param >= 0x1E)))
@@ -2085,7 +2080,6 @@ void CSoundFile::SetSpeed(UINT param)
 		}
 	}
 #endif // MODPLUG_FASTSOUNDLIB
-#endif // MODPLUG_TRACKER
 	if ((m_nType & MOD_TYPE_S3M) && (param > 0x80)) param -= 0x80;
 	if ((param) && (param <= max)) m_nMusicSpeed = param;
 }
diff --git a/src/sndfile.cpp b/src/sndfile.cpp
index 2dfc79e..c79e8fa 100644
--- a/src/sndfile.cpp
+++ b/src/sndfile.cpp
@@ -9,8 +9,6 @@
 #include "libmodplug/stdafx.h"
 #include "libmodplug/sndfile.h"
 
-#define MMCMP_SUPPORT
-
 #ifdef MMCMP_SUPPORT
 extern BOOL MMCMP_Unpack(LPCBYTE *ppMemFile, LPDWORD pdwMemLength);
 #endif
@@ -24,24 +22,6 @@ extern void ITUnpack8Bit(signed char *pSample, DWORD dwLen, LPBYTE lpMemFile, DW
 extern void ITUnpack16Bit(signed char *pSample, DWORD dwLen, LPBYTE lpMemFile, DWORD dwMemLength, BOOL b215);
 
 
-#define MAX_PACK_TABLES		3
-
-
-// Compression table
-static const signed char UnpackTable[MAX_PACK_TABLES][16] =
-//--------------------------------------------
-{
-	// CPU-generated dynamic table
-	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
-	// u-Law table
-	{0, 1, 2, 4, 8, 16, 32, 64,
-	-1, -2, -4, -8, -16, -32, -48, -64},
-	// Linear table
-	{0, 1, 2, 3, 5, 7, 12, 19,
-	-1, -2, -3, -5, -7, -12, -19, -31}
-};
-
-
 //////////////////////////////////////////////////////////
 // CSoundFile
 
@@ -140,12 +120,16 @@ BOOL CSoundFile::Create(LPCBYTE lpStream, DWORD dwMemLength)
 		if ((!ReadXM(lpStream, dwMemLength))
 		 && (!ReadS3M(lpStream, dwMemLength))
 		 && (!ReadIT(lpStream, dwMemLength))
+#ifdef WAV_SUPPORT
 		 && (!ReadWav(lpStream, dwMemLength))
+#endif
 #ifndef MODPLUG_BASIC_SUPPORT
+#ifdef MIDIFMT_SUPPORT
 /* Sequencer File Format Support */
 		 && (!ReadABC(lpStream, dwMemLength))
 		 && (!ReadMID(lpStream, dwMemLength))
 		 && (!ReadPAT(lpStream, dwMemLength))
+#endif
 		 && (!ReadSTM(lpStream, dwMemLength))
 		 && (!ReadMed(lpStream, dwMemLength))
 		 && (!ReadMTM(lpStream, dwMemLength))
@@ -168,7 +152,7 @@ BOOL CSoundFile::Create(LPCBYTE lpStream, DWORD dwMemLength)
 #ifdef MMCMP_SUPPORT
 		if (bMMCmp)
 		{
-			GlobalFreePtr(lpStream);
+			free((void*)lpStream);
 			lpStream = NULL;
 		}
 #endif
@@ -355,7 +339,7 @@ void CSoundFile::FreePattern(LPVOID pat)
 signed char* CSoundFile::AllocateSample(UINT nbytes)
 //-------------------------------------------
 {
-	signed char * p = (signed char *)GlobalAllocPtr(GHND, (nbytes+39) & ~7);
+	signed char * p = (signed char *)calloc(1, (nbytes+39) & ~7);
 	if (p) p += 16;
 	return p;
 }
@@ -364,9 +348,8 @@ signed char* CSoundFile::AllocateSample(UINT nbytes)
 void CSoundFile::FreeSample(LPVOID p)
 //-----------------------------------
 {
-	if (p)
-	{
-		GlobalFreePtr(((LPSTR)p)-16);
+	if (p) {
+		free((char*)p - 16);
 	}
 }
 
@@ -753,41 +736,6 @@ void CSoundFile::LoopPattern(int nPat, int nRow)
 }
 
 
-UINT CSoundFile::GetBestSaveFormat() const
-//----------------------------------------
-{
-	if ((!m_nSamples) || (!m_nChannels)) return MOD_TYPE_NONE;
-	if (!m_nType) return MOD_TYPE_NONE;
-	if (m_nType & (MOD_TYPE_MOD|MOD_TYPE_OKT))
-		return MOD_TYPE_MOD;
-	if (m_nType & (MOD_TYPE_S3M|MOD_TYPE_STM|MOD_TYPE_ULT|MOD_TYPE_FAR|MOD_TYPE_PTM))
-		return MOD_TYPE_S3M;
-	if (m_nType & (MOD_TYPE_XM|MOD_TYPE_MED|MOD_TYPE_MTM|MOD_TYPE_MT2))
-		return MOD_TYPE_XM;
-	return MOD_TYPE_IT;
-}
-
-
-UINT CSoundFile::GetSaveFormats() const
-//-------------------------------------
-{
-	UINT n = 0;
-	if ((!m_nSamples) || (!m_nChannels) || (m_nType == MOD_TYPE_NONE)) return 0;
-	if (m_nType & MOD_TYPE_MOD)
-		n |= MOD_TYPE_MOD;
-	if (m_nType & MOD_TYPE_S3M)
-		n |= MOD_TYPE_S3M;
-	// Can always save to XM & IT
-	n |= MOD_TYPE_XM | MOD_TYPE_IT;
-	if (!m_nInstruments)
-	{
-		if (m_nSamples < 32) n |= MOD_TYPE_MOD;
-		n |= MOD_TYPE_S3M;
-	}
-	return n;
-}
-
-
 UINT CSoundFile::GetSampleName(UINT nSample,LPSTR s) const
 //--------------------------------------------------------
 {
@@ -817,274 +765,6 @@ UINT CSoundFile::GetInstrumentName(UINT nInstr,LPSTR s) const
 }
 
 
-#ifndef NO_PACKING
-UINT CSoundFile::PackSample(int &sample, int next)
-//------------------------------------------------
-{
-	UINT i = 0;
-	int delta = next - sample;
-	if (delta >= 0)
-	{
-		for (i=0; i<7; i++) if (delta <= (int)CompressionTable[i+1]) break;
-	} else
-	{
-		for (i=8; i<15; i++) if (delta >= (int)CompressionTable[i+1]) break;
-	}
-	sample += (int)CompressionTable[i];
-	return i;
-}
-
-
-BOOL CSoundFile::CanPackSample(LPSTR pSample, UINT nLen, UINT nPacking, BYTE *result)
-//-----------------------------------------------------------------------------------
-{
-	int pos, old, oldpos, besttable = 0;
-	DWORD dwErr, dwTotal, dwResult;
-	int i,j;
-
-	if (result) *result = 0;
-	if ((!pSample) || (nLen < 1024)) return FALSE;
-	// Try packing with different tables
-	dwResult = 0;
-	for (j=1; j<MAX_PACK_TABLES; j++)
-	{
-		memcpy(CompressionTable, UnpackTable[j], 16);
-		dwErr = 0;
-		dwTotal = 1;
-		old = pos = oldpos = 0;
-		for (i=0; i<(int)nLen; i++)
-		{
-			int s = (int)pSample[i];
-			PackSample(pos, s);
-			dwErr += abs(pos - oldpos);
-			dwTotal += abs(s - old);
-			old = s;
-			oldpos = pos;
-		}
-		dwErr = _muldiv(dwErr, 100, dwTotal);
-		if (dwErr >= dwResult)
-		{
-			dwResult = dwErr;
-			besttable = j;
-		}
-	}
-	memcpy(CompressionTable, UnpackTable[besttable], 16);
-	if (result)
-	{
-		if (dwResult > 100) *result	= 100; else *result = (BYTE)dwResult;
-	}
-	return (dwResult >= nPacking) ? TRUE : FALSE;
-}
-#endif // NO_PACKING
-
-#ifndef MODPLUG_NO_FILESAVE
-
-UINT CSoundFile::WriteSample(FILE *f, MODINSTRUMENT *pins, UINT nFlags, UINT nMaxLen)
-//-----------------------------------------------------------------------------------
-{
-	UINT len = 0, bufcount;
-	signed char buffer[4096];
-	signed char *pSample = (signed char *)pins->pSample;
-	UINT nLen = pins->nLength;
-
-	if ((nMaxLen) && (nLen > nMaxLen)) nLen = nMaxLen;
-	if ((!pSample) || (f == NULL) || (!nLen)) return 0;
-	switch(nFlags)
-	{
-#ifndef NO_PACKING
-	// 3: 4-bit ADPCM data
-	case RS_ADPCM4:
-		{
-			int pos;
-			len = (nLen + 1) / 2;
-			fwrite(CompressionTable, 16, 1, f);
-			bufcount = 0;
-			pos = 0;
-			for (UINT j=0; j<len; j++)
-			{
-				BYTE b;
-				// Sample #1
-				b = PackSample(pos, (int)pSample[j*2]);
-				// Sample #2
-				b |= PackSample(pos, (int)pSample[j*2+1]) << 4;
-				buffer[bufcount++] = (signed char)b;
-				if (bufcount >= sizeof(buffer))
-				{
-					fwrite(buffer, 1, bufcount, f);
-					bufcount = 0;
-				}
-			}
-			if (bufcount) fwrite(buffer, 1, bufcount, f);
-			len += 16;
-		}
-		break;
-#endif // NO_PACKING
-
-	// 16-bit samples
-	case RS_PCM16U:
-	case RS_PCM16D:
-	case RS_PCM16S:
-		{
-			int16_t *p = (int16_t *)pSample;
-			int s_old = 0, s_ofs;
-			len = nLen * 2;
-			bufcount = 0;
-			s_ofs = (nFlags == RS_PCM16U) ? 0x8000 : 0;
-			for (UINT j=0; j<nLen; j++)
-			{
-				int s_new = *p;
-				p++;
-				if (pins->uFlags & CHN_STEREO)
-				{
-					s_new = (s_new + (*p) + 1) >> 1;
-					p++;
-				}
-				if (nFlags == RS_PCM16D)
-				{
-					int16_t temp = bswapLE16((int16_t)(s_new - s_old));
-					*((int16_t*)(&buffer[bufcount])) = temp;
-					s_old = s_new;
-				} else
-				{
-					int16_t temp = bswapLE16((int16_t)(s_new + s_ofs));
-					*((int16_t *)(&buffer[bufcount])) = temp;
-				}
-				bufcount += 2;
-				if (bufcount >= sizeof(buffer) - 1)
-				{
-					fwrite(buffer, 1, bufcount, f);
-					bufcount = 0;
-				}
-			}
-			if (bufcount) fwrite(buffer, 1, bufcount, f);
-		}
-		break;
-
-
-	// 8-bit Stereo samples (not interleaved)
-	case RS_STPCM8S:
-	case RS_STPCM8U:
-	case RS_STPCM8D:
-		{
-			int s_ofs = (nFlags == RS_STPCM8U) ? 0x80 : 0;
-			for (UINT iCh=0; iCh<2; iCh++)
-			{
-				signed char *p = pSample + iCh;
-				int s_old = 0;
-
-				bufcount = 0;
-				for (UINT j=0; j<nLen; j++)
-				{
-					int s_new = *p;
-					p += 2;
-					if (nFlags == RS_STPCM8D)
-					{
-						buffer[bufcount++] = (signed char)(s_new - s_old);
-						s_old = s_new;
-					} else
-					{
-						buffer[bufcount++] = (signed char)(s_new + s_ofs);
-					}
-					if (bufcount >= sizeof(buffer))
-					{
-						fwrite(buffer, 1, bufcount, f);
-						bufcount = 0;
-					}
-				}
-				if (bufcount) fwrite(buffer, 1, bufcount, f);
-			}
-		}
-		len = nLen * 2;
-		break;
-
-	// 16-bit Stereo samples (not interleaved)
-	case RS_STPCM16S:
-	case RS_STPCM16U:
-	case RS_STPCM16D:
-		{
-			int s_ofs = (nFlags == RS_STPCM16U) ? 0x8000 : 0;
-			for (UINT iCh=0; iCh<2; iCh++)
-			{
-				int16_t *p = ((int16_t *)pSample) + iCh;
-				int s_old = 0;
-
-				bufcount = 0;
-				for (UINT j=0; j<nLen; j++)
-				{
-					int s_new = *p;
-					p += 2;
-					if (nFlags == RS_STPCM16D)
-					{
-						int16_t temp = bswapLE16((int16_t)(s_new - s_old));
-						*((int16_t *)(&buffer[bufcount])) = temp;
-						s_old = s_new;
-					} else
-					{
-						int16_t temp = bswapLE16((int16_t)(s_new - s_ofs));
-						*((int16_t*)(&buffer[bufcount])) = temp;
-					}
-					bufcount += 2;
-					if (bufcount >= sizeof(buffer))
-					{
-						fwrite(buffer, 1, bufcount, f);
-						bufcount = 0;
-					}
-				}
-				if (bufcount) fwrite(buffer, 1, bufcount, f);
-			}
-		}
-		len = nLen*4;
-		break;
-
-	//	Stereo signed interleaved
-	case RS_STIPCM8S:
-	case RS_STIPCM16S:
-		len = nLen * 2;
-		if (nFlags == RS_STIPCM16S) len *= 2;
-		fwrite(pSample, 1, len, f);
-		break;
-
-	// Default: assume 8-bit PCM data
-	default:
-		len = nLen;
-		bufcount = 0;
-		{
-			signed char *p = pSample;
-			int sinc = (pins->uFlags & CHN_16BIT) ? 2 : 1;
-			int s_old = 0, s_ofs = (nFlags == RS_PCM8U) ? 0x80 : 0;
-			if (pins->uFlags & CHN_16BIT) p++;
-			for (UINT j=0; j<len; j++)
-			{
-				int s_new = (signed char)(*p);
-				p += sinc;
-				if (pins->uFlags & CHN_STEREO)
-				{
-					s_new = (s_new + ((int)*p) + 1) >> 1;
-					p += sinc;
-				}
-				if (nFlags == RS_PCM8D)
-				{
-					buffer[bufcount++] = (signed char)(s_new - s_old);
-					s_old = s_new;
-				} else
-				{
-					buffer[bufcount++] = (signed char)(s_new + s_ofs);
-				}
-				if (bufcount >= sizeof(buffer))
-				{
-					fwrite(buffer, 1, bufcount, f);
-					bufcount = 0;
-				}
-			}
-			if (bufcount) fwrite(buffer, 1, bufcount, f);
-		}
-	}
-	return len;
-}
-
-#endif // MODPLUG_NO_FILESAVE
-
-
 // Flags:
 //	0 = signed 8-bit PCM data (default)
 //	1 = unsigned 8-bit PCM data
@@ -1376,17 +1056,18 @@ UINT CSoundFile::ReadSample(MODINSTRUMENT *pIns, UINT nFlags, LPCSTR lpMemFile,
 	// PTM 8bit delta to 16-bit sample
 	case RS_PTM8DTO16:
 		{
+			UINT j;
 			len = pIns->nLength * 2;
 			if (len > dwMemLength) break;
 			int8_t *pSample = (int8_t *)pIns->pSample;
 			int8_t delta8 = 0;
-			for (UINT j=0; j<len; j++)
+			for (j=0; j<len; j++)
 			{
 				delta8 += lpMemFile[j];
 				*pSample++ = delta8;
 			}
 			uint16_t *pSampleW = (uint16_t *)pIns->pSample;
-			for (UINT j=0; j<len; j+=2)   // swaparoni!
+			for (j=0; j<len; j+=2)   // swaparoni!
 			{
 				uint16_t rawSample = *pSampleW;
 			        *pSampleW++ = bswapLE16(rawSample);
@@ -1448,88 +1129,6 @@ UINT CSoundFile::ReadSample(MODINSTRUMENT *pIns, UINT nFlags, LPCSTR lpMemFile,
 			len = DMFUnpack((LPBYTE)pIns->pSample, ibuf, ibufmax, maxlen);
 		}
 		break;
-
-#ifdef MODPLUG_TRACKER
-	// PCM 24-bit signed -> load sample, and normalize it to 16-bit
-	case RS_PCM24S:
-	case RS_PCM32S:
-		len = pIns->nLength * 3;
-		if (nFlags == RS_PCM32S) len += pIns->nLength;
-		if (len > dwMemLength) break;
-		if (len > 4*8)
-		{
-			UINT slsize = (nFlags == RS_PCM32S) ? 4 : 3;
-			LPBYTE pSrc = (LPBYTE)lpMemFile;
-			LONG max = 255;
-			if (nFlags == RS_PCM32S) pSrc++;
-			for (UINT j=0; j<len; j+=slsize)
-			{
-				LONG l = ((((pSrc[j+2] << 8) + pSrc[j+1]) << 8) + pSrc[j]) << 8;
-				l /= 256;
-				if (l > max) max = l;
-				if (-l > max) max = -l;
-			}
-			max = (max / 128) + 1;
-			int16_t *pDest = (int16_t *)pIns->pSample;
-			for (UINT k=0; k<len; k+=slsize)
-			{
-				LONG l = ((((pSrc[k+2] << 8) + pSrc[k+1]) << 8) + pSrc[k]) << 8;
-				*pDest++ = (uint16_t)(l / max);
-			}
-		}
-		break;
-
-	// Stereo PCM 24-bit signed -> load sample, and normalize it to 16-bit
-	case RS_STIPCM24S:
-	case RS_STIPCM32S:
-		len = pIns->nLength * 6;
-		if (nFlags == RS_STIPCM32S) len += pIns->nLength * 2;
-		if (len > dwMemLength) break;
-		if (len > 8*8)
-		{
-			UINT slsize = (nFlags == RS_STIPCM32S) ? 4 : 3;
-			LPBYTE pSrc = (LPBYTE)lpMemFile;
-			LONG max = 255;
-			if (nFlags == RS_STIPCM32S) pSrc++;
-			for (UINT j=0; j<len; j+=slsize)
-			{
-				LONG l = ((((pSrc[j+2] << 8) + pSrc[j+1]) << 8) + pSrc[j]) << 8;
-				l /= 256;
-				if (l > max) max = l;
-				if (-l > max) max = -l;
-			}
-			max = (max / 128) + 1;
-			int16_t *pDest = (int16_t *)pIns->pSample;
-			for (UINT k=0; k<len; k+=slsize)
-			{
-				LONG lr = ((((pSrc[k+2] << 8) + pSrc[k+1]) << 8) + pSrc[k]) << 8;
-				k += slsize;
-				LONG ll = ((((pSrc[k+2] << 8) + pSrc[k+1]) << 8) + pSrc[k]) << 8;
-				pDest[0] = (int16_t)ll;
-				pDest[1] = (int16_t)lr;
-				pDest += 2;
-			}
-		}
-		break;
-
-	// 16-bit signed big endian interleaved stereo
-	case RS_STIPCM16M:
-		{
-			len = pIns->nLength;
-			if (len*4 > dwMemLength) len = dwMemLength >> 2;
-			LPCBYTE psrc = (LPCBYTE)lpMemFile;
-			int16_t *pSample = (int16_t *)pIns->pSample;
-			for (UINT j=0; j<len; j++)
-			{
-				pSample[j*2] = (int16_t)(((UINT)psrc[0] << 8) | (psrc[1]));
-				pSample[j*2+1] = (int16_t)(((UINT)psrc[2] << 8) | (psrc[3]));
-				psrc += 4;
-			}
-			len *= 4;
-		}
-		break;
-
-#endif // MODPLUG_TRACKER
 #endif // !MODPLUG_FASTSOUNDLIB
 #endif // !MODPLUG_BASIC_SUPPORT
 
@@ -1654,8 +1253,7 @@ void CSoundFile::AdjustSampleLoop(MODINSTRUMENT *pIns)
 DWORD CSoundFile::TransposeToFrequency(int transp, int ftune)
 //-----------------------------------------------------------
 {
-
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 	const float _fbase = 8363;
 	const float _factor = 1.0f/(12.0f*128.0f);
 	int result;
@@ -1695,8 +1293,7 @@ DWORD CSoundFile::TransposeToFrequency(int transp, int ftune)
 int CSoundFile::FrequencyToTranspose(DWORD freq)
 //----------------------------------------------
 {
-
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 	const float _f1_8363 = 1.0f / 8363.0f;
 	const float _factor = 128 * 12;
 	LONG result;
diff --git a/src/sndmix.cpp b/src/sndmix.cpp
index 20f722f..426f8ab 100644
--- a/src/sndmix.cpp
+++ b/src/sndmix.cpp
@@ -8,10 +8,6 @@
 #include "libmodplug/sndfile.h"
 #include "tables.h"
 
-#ifdef MODPLUG_TRACKER
-#define ENABLE_STEREOVU
-#endif
-
 // Volume ramp length, in 1/10 ms
 #define VOLUMERAMPLEN	146	// 1.46ms = 64 samples at 44.1kHz
 
@@ -60,7 +56,7 @@ UINT gnReverbSend;
 
 // Log tables for pre-amp
 // We don't want the tracker to get too loud
-const UINT PreAmpTable[16] =
+static const UINT PreAmpTable[16] =
 {
 	0x60, 0x60, 0x60, 0x70,	// 0-7
 	0x80, 0x88, 0x90, 0x98,	// 8-15
@@ -68,7 +64,7 @@ const UINT PreAmpTable[16] =
 	0xB4, 0xB8, 0xBC, 0xC0,	// 24-31
 };
 
-const UINT PreAmpAGCTable[16] =
+static const UINT PreAmpAGCTable[16] =
 {
 	0x60, 0x60, 0x60, 0x60,
 	0x68, 0x70, 0x78, 0x80,
@@ -80,7 +76,7 @@ const UINT PreAmpAGCTable[16] =
 // Return (a*b)/c - no divide error
 int _muldiv(long a, long b, long c)
 {
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 	int sign, result;
 	_asm {
 	mov eax, a
@@ -123,11 +119,10 @@ rneg:
 #endif
 }
 
-
 // Return (a*b+c/2)/c - no divide error
 int _muldivr(long a, long b, long c)
 {
-#ifdef MSC_VER
+#if defined(_MSC_VER) && defined(_M_IX86)
 	int sign, result;
 	_asm {
 	mov eax, a
@@ -340,7 +335,6 @@ MixDone:
 }
 
 
-
 /////////////////////////////////////////////////////////////////////////////
 // Handles navigation/effects
 
@@ -504,9 +498,6 @@ BOOL CSoundFile::ReadNote()
 		if ((pChn->dwFlags & CHN_MUTE) || ((nChn >= m_nChannels) && (!pChn->nLength)))
 		{
 			pChn->nVUMeter = 0;
-#ifdef ENABLE_STEREOVU
-			pChn->nLeftVU = pChn->nRightVU = 0;
-#endif
 			continue;
 		}
 		// Reset channel data
@@ -1038,56 +1029,17 @@ BOOL CSoundFile::ReadNote()
 				}
 			}
 		}
-#ifdef MODPLUG_PLAYER
-		// Limit CPU -> > 80% -> don't ramp
-		if ((gnCPUUsage >= 80) && (!pChn->nRealVolume))
-		{
-			pChn->nLeftVol = pChn->nRightVol = 0;
-		}
-#endif // MODPLUG_PLAYER
 		// Volume ramping
 		pChn->dwFlags &= ~CHN_VOLUMERAMP;
 		if ((pChn->nRealVolume) || (pChn->nLeftVol) || (pChn->nRightVol))
 			pChn->dwFlags |= CHN_VOLUMERAMP;
-#ifdef MODPLUG_PLAYER
-		// Decrease VU-Meter
-		if (pChn->nVUMeter > VUMETER_DECAY)	pChn->nVUMeter -= VUMETER_DECAY; else pChn->nVUMeter = 0;
-#endif // MODPLUG_PLAYER
-#ifdef ENABLE_STEREOVU
-		if (pChn->nLeftVU > VUMETER_DECAY) pChn->nLeftVU -= VUMETER_DECAY; else pChn->nLeftVU = 0;
-		if (pChn->nRightVU > VUMETER_DECAY) pChn->nRightVU -= VUMETER_DECAY; else pChn->nRightVU = 0;
-#endif
 		// Check for too big nInc
 		if (((pChn->nInc >> 16) + 1) >= (LONG)(pChn->nLoopEnd - pChn->nLoopStart)) pChn->dwFlags &= ~CHN_LOOP;
 		pChn->nNewRightVol = pChn->nNewLeftVol = 0;
 		pChn->pCurrentSample = ((pChn->pSample) && (pChn->nLength) && (pChn->nInc)) ? pChn->pSample : NULL;
 		if (pChn->pCurrentSample)
 		{
-			// Update VU-Meter (nRealVolume is 14-bit)
-#ifdef MODPLUG_PLAYER
-			UINT vutmp = pChn->nRealVolume >> (14 - 8);
-			if (vutmp > 0xFF) vutmp = 0xFF;
-			if (pChn->nVUMeter >= 0x100) pChn->nVUMeter = vutmp;
-			vutmp >>= 1;
-			if (pChn->nVUMeter < vutmp)	pChn->nVUMeter = vutmp;
-#endif // MODPLUG_PLAYER
-#ifdef ENABLE_STEREOVU
-			UINT vul = (pChn->nRealVolume * pChn->nRealPan) >> 14;
-			if (vul > 127) vul = 127;
-			if (pChn->nLeftVU > 127) pChn->nLeftVU = (BYTE)vul;
-			vul >>= 1;
-			if (pChn->nLeftVU < vul) pChn->nLeftVU = (BYTE)vul;
-			UINT vur = (pChn->nRealVolume * (256-pChn->nRealPan)) >> 14;
-			if (vur > 127) vur = 127;
-			if (pChn->nRightVU > 127) pChn->nRightVU = (BYTE)vur;
-			vur >>= 1;
-			if (pChn->nRightVU < vur) pChn->nRightVU = (BYTE)vur;
-#endif
-#ifdef MODPLUG_TRACKER
-			UINT kChnMasterVol = (pChn->dwFlags & CHN_EXTRALOUD) ? 0x100 : nMasterVol;
-#else
 #define		kChnMasterVol	nMasterVol
-#endif // MODPLUG_TRACKER
 			// Adjusting volumes
 			if (gnChannels >= 2)
 			{
@@ -1196,11 +1148,6 @@ BOOL CSoundFile::ReadNote()
 			if (m_nMixChannels >= MAX_CHANNELS) break;
 		} else
 		{
-#ifdef ENABLE_STEREOVU
-			// Note change but no sample
-			if (pChn->nLeftVU > 128) pChn->nLeftVU = 0;
-			if (pChn->nRightVU > 128) pChn->nRightVU = 0;
-#endif
 			if (pChn->nVUMeter > 0xFF) pChn->nVUMeter = 0;
 			pChn->nLeftVol = pChn->nRightVol = 0;
 			pChn->nLength = 0;

diff -u libmodplug-0.8.9.0/configure~ libmodplug-0.8.9.0/configure
--- libmodplug-0.8.9.0/configure~
+++ libmodplug-0.8.9.0/configure
@@ -634,6 +634,8 @@
 LTLIBOBJS
 LIBOBJS
 MODPLUG_LIBRARY_VERSION
+EXPORT_CXX_FALSE
+EXPORT_CXX_TRUE
 LT_LDFLAGS
 LT_SYS_LIBRARY_PATH
 OTOOL64
@@ -772,6 +774,10 @@
 with_gnu_ld
 with_sysroot
 enable_libtool_lock
+enable_cxx_interface
+enable_midi
+enable_wav
+enable_mmcmp
 '
       ac_precious_vars='build_alias
 host_alias
@@ -1418,6 +1424,11 @@
   --enable-fast-install[=PKGS]
                           optimize for fast installation [default=yes]
   --disable-libtool-lock  avoid locking (might break parallel builds)
+  --enable-cxx-interface  export C++ interface from library [[default=yes]]
+  --enable-midi           compile with midi formats support [[default=no]]
+  --enable-wav            compile with wav formats support [[default=no]]
+  --enable-mmcmp          compile with mmcmp and pp20 decompression support
+                          [[default=no]]
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -16702,13 +16713,12 @@
 
 done
 
-for ac_func in setenv sinf
+for ac_func in sinf
 do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_cxx_check_func "$LINENO" "$ac_func" "$as_ac_var"
-if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  ac_fn_cxx_check_func "$LINENO" "sinf" "ac_cv_func_sinf"
+if test "x$ac_cv_func_sinf" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_SINF 1
 _ACEOF
 
 fi
@@ -16786,6 +16796,66 @@
 		;;
 esac
 
+# Check whether --enable-cxx_interface was given.
+if test "${enable_cxx_interface+set}" = set; then :
+  enableval=$enable_cxx_interface;
+else
+  enable_cxx_interface=yes
+fi
+
+if test x$enable_cxx_interface != xyes; then
+
+$as_echo "#define NO_CXX_EXPORTS 1" >>confdefs.h
+
+fi
+ if test x$enable_cxx_interface = xyes; then
+  EXPORT_CXX_TRUE=
+  EXPORT_CXX_FALSE='#'
+else
+  EXPORT_CXX_TRUE='#'
+  EXPORT_CXX_FALSE=
+fi
+
+
+# Check whether --enable-midi was given.
+if test "${enable_midi+set}" = set; then :
+  enableval=$enable_midi;
+else
+  enable_midi=no
+fi
+
+if test x$enable_midi = xyes; then
+
+$as_echo "#define MIDIFMT_SUPPORT 1" >>confdefs.h
+
+fi
+
+# Check whether --enable-wav was given.
+if test "${enable_wav+set}" = set; then :
+  enableval=$enable_wav;
+else
+  enable_wav=no
+fi
+
+if test x$enable_wav = xyes; then
+
+$as_echo "#define WAV_SUPPORT 1" >>confdefs.h
+
+fi
+
+# Check whether --enable-mmcmp was given.
+if test "${enable_mmcmp+set}" = set; then :
+  enableval=$enable_mmcmp;
+else
+  enable_mmcmp=no
+fi
+
+if test x$enable_mmcmp = xyes; then
+
+$as_echo "#define MMCMP_SUPPORT 1" >>confdefs.h
+
+fi
+
 # portable types. requires autoconf 2.60
 # `configure' will check if these are defined in system headers.
 # if not, it will auto-detect and define them in `config.h'
@@ -17036,6 +17106,10 @@
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 
+if test -z "${EXPORT_CXX_TRUE}" && test -z "${EXPORT_CXX_FALSE}"; then
+  as_fn_error $? "conditional \"EXPORT_CXX\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 
 : "${CONFIG_STATUS=./config.status}"
 ac_write_fail=0
diff -u libmodplug-0.8.9.0/Makefile.in~ libmodplug-0.8.9.0b/Makefile.in
--- libmodplug-0.8.9.0/Makefile.in~
+++ libmodplug-0.8.9.0/Makefile.in
@@ -359,7 +359,7 @@
 top_srcdir = @top_srcdir@
 ACLOCAL_AMFLAGS = -I m4
 SUBDIRS = src
-EXTRA_DIST = \
+EXTRA_DIST = CMakeLists.txt \
 	AUTHORS COPYING ChangeLog \
 	INSTALL README TODO
 
diff -u libmodplug-0.8.9.0/src/Makefile.in~ libmodplug-0.8.9.0/src/Makefile.in
--- libmodplug-0.8.9.0/src/Makefile.in~
+++ libmodplug-0.8.9.0/src/Makefile.in
@@ -97,8 +97,9 @@
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
-DIST_COMMON = $(srcdir)/Makefile.am $(libmodpluginclude_HEADERS) \
-	$(noinst_HEADERS) $(am__DIST_COMMON)
+DIST_COMMON = $(srcdir)/Makefile.am \
+	$(am__libmodpluginclude_HEADERS_DIST) $(noinst_HEADERS) \
+	$(am__DIST_COMMON)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES =
@@ -139,8 +140,8 @@
 	load_umx.lo load_ult.lo load_stm.lo load_s3m.lo load_ptm.lo \
 	load_okt.lo load_mtm.lo load_mod.lo load_med.lo load_mdl.lo \
 	load_it.lo load_far.lo load_dsm.lo load_dmf.lo load_dbm.lo \
-	load_ams.lo load_amf.lo load_669.lo load_j2b.lo load_mt2.lo \
-	load_psm.lo load_abc.lo load_mid.lo load_pat.lo modplug.lo
+	load_ams.lo load_amf.lo load_669.lo load_mt2.lo load_psm.lo \
+	load_abc.lo load_mid.lo load_pat.lo modplug.lo
 libmodplug_la_OBJECTS = $(am_libmodplug_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -209,6 +210,8 @@
     n|no|NO) false;; \
     *) (install-info --version) >/dev/null 2>&1;; \
   esac
+am__libmodpluginclude_HEADERS_DIST = modplug.h libmodplug/stdafx.h \
+	libmodplug/sndfile.h libmodplug/it_defs.h
 HEADERS = $(libmodpluginclude_HEADERS) $(noinst_HEADERS)
 am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) \
 	$(LISP)config.h.in
@@ -392,7 +395,6 @@
                         load_ams.cpp       \
                         load_amf.cpp       \
                         load_669.cpp       \
-                        load_j2b.cpp       \
                         load_mt2.cpp       \
                         load_psm.cpp       \
                         load_abc.cpp       \
@@ -401,7 +403,8 @@
                         modplug.cpp
 
 libmodplugincludedir = $(includedir)/libmodplug
-libmodpluginclude_HEADERS = libmodplug/stdafx.h libmodplug/sndfile.h libmodplug/it_defs.h modplug.h
+@EXPORT_CXX_TRUE@HEADERS_CXX = libmodplug/stdafx.h libmodplug/sndfile.h libmodplug/it_defs.h
+libmodpluginclude_HEADERS = modplug.h $(HEADERS_CXX)
 noinst_HEADERS = load_pat.h
 all: config.h
 	$(MAKE) $(AM_MAKEFLAGS) all-am
@@ -507,7 +510,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_dsm.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_far.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_it.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_j2b.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_mdl.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_med.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_mid.Plo@am__quote@

